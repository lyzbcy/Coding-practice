# LeetCode 141. 环形链表 - 详细教学文档

## 📚 目录

1. [问题分析](#问题分析)
2. [思路解析](#思路解析)
3. [算法详解](#算法详解)
4. [代码实现](#代码实现)
5. [复杂度分析](#复杂度分析)
6. [常见错误](#常见错误)
7. [扩展思考](#扩展思考)

---

## 问题分析

### 题目要求

- 给定一个链表的头节点 `head`
- 判断链表中是否存在环
- 环的定义：链表中某个节点可以通过连续跟踪 `next` 指针再次到达

### 关键约束

1. **链表长度**：
   - 节点数目范围是 `[0, 10^4]`
   - 需要 O(n) 或更优的算法

2. **空间复杂度要求**：
   - 进阶要求：O(1) 空间复杂度
   - 不能使用哈希表等额外数据结构

3. **不能修改链表**：
   - 不能改变链表结构
   - 不能破坏链表

---

## 思路解析

### 错误直觉 ❌

1. **使用哈希表存储节点**：
   - 遍历链表，将每个节点存入哈希表
   - 如果遇到已存在的节点，说明有环
   - **问题**：空间复杂度 O(n)，不符合进阶要求

2. **标记节点**：
   - 遍历时修改节点值作为标记
   - **问题**：题目要求不能修改链表

3. **暴力遍历**：
   - 对每个节点，检查它是否在后续节点中出现
   - **问题**：时间复杂度 O(n²)，效率太低

### 正确思路 ✅

本题的核心是**快慢指针（Floyd判圈算法）**：

1. **基本思想**：
   - 使用两个指针，一个慢指针（每次移动一步），一个快指针（每次移动两步）
   - 如果链表有环，快指针最终会追上慢指针（相遇）
   - 如果链表没有环，快指针会先到达链表末尾（NULL）

2. **为什么快慢指针能检测环？**
   - **数学原理**：假设环的长度为 `C`，慢指针进入环时，快指针已经在环中
   - 快指针相对于慢指针的速度是 1 步/次（快指针每次比慢指针多走 1 步）
   - 最坏情况下，快指针需要走 `C-1` 步才能追上慢指针
   - 因此，时间复杂度是 O(n)

3. **判断条件**：
   - 如果 `slow == fast`：快慢指针相遇，存在环，返回 `true`
   - 如果 `fast == NULL` 或 `fast->next == NULL`：快指针到达末尾，不存在环，返回 `false`

伪代码：

```
slow = head
fast = head->next

while fast != NULL and fast->next != NULL:
    if slow == fast:
        return true  // 相遇，有环
    slow = slow->next  // 慢指针移动一步
    fast = fast->next->next  // 快指针移动两步

return false  // 快指针到达末尾，无环
```

---

## 算法详解

### 核心思想

**Floyd判圈算法（龟兔赛跑算法）**：使用两个指针以不同速度遍历链表，如果存在环，快指针最终会追上慢指针。

### 执行步骤

1. **初始化指针**
   - `slow = head`：慢指针，每次移动一步
   - `fast = head->next`：快指针，每次移动两步
   - 注意：`fast` 从 `head->next` 开始，避免初始时 `slow == fast`

2. **遍历链表**
   - 如果 `fast == NULL` 或 `fast->next == NULL`：说明快指针到达末尾，没有环，返回 `false`
   - 如果 `slow == fast`：说明快慢指针相遇，存在环，返回 `true`
   - 否则：继续移动指针
     - `slow = slow->next`
     - `fast = fast->next->next`

3. **边界条件**
   - 空链表（`head == NULL`）：返回 `false`
   - 单节点链表（`head->next == NULL`）：返回 `false`

### 示例演示

**示例 1：有环链表** `head = [3,2,0,-4]`, `pos = 1`

```
初始状态：
3 -> 2 -> 0 -> -4
^              |
|______________|

slow = 3 (head)
fast = 2 (head->next)

步骤 1：
slow = 2, fast = 0
slow != fast，继续

步骤 2：
slow = 0, fast = 2
slow != fast，继续

步骤 3：
slow = -4, fast = -4
slow == fast！相遇，返回 true
```

**示例 2：无环链表** `head = [1]`

```
初始状态：
1 -> NULL

slow = 1 (head)
fast = NULL (head->next)

fast == NULL，返回 false
```

**示例 3：有环链表（环在头部）** `head = [1,2]`, `pos = 0`

```
初始状态：
1 -> 2
^    |
|____|

slow = 1 (head)
fast = 2 (head->next)

步骤 1：
slow = 2, fast = 1
slow != fast，继续

步骤 2：
slow = 1, fast = 2
slow != fast，继续

步骤 3：
slow = 2, fast = 1
slow != fast，继续

...（继续循环，直到相遇）

步骤 N：
slow = 1, fast = 1
slow == fast！相遇，返回 true
```

### 为什么快慢指针一定能相遇？

**数学证明**：

假设：
- 链表长度为 `L`
- 环的长度为 `C`
- 从链表头到环入口的距离为 `a`
- 慢指针进入环时，快指针在环中的位置为 `b`（距离环入口 `b` 步）

当慢指针进入环时：
- 慢指针位置：`a`
- 快指针位置：`(a + b) % C`

快指针相对于慢指针的速度是 1 步/次，因此：
- 快指针需要 `(C - b) % C` 步才能追上慢指针
- 最坏情况下，需要 `C-1` 步

由于 `C <= L`，所以时间复杂度是 O(n)。

---

## 代码实现

### C 语言核心代码

```c
#include <stdbool.h>

bool hasCycle(struct ListNode *head) {
    // 边界条件：空链表或单节点链表
    if (head == NULL || head->next == NULL) {
        return false;
    }
    
    // 初始化快慢指针
    struct ListNode *slow = head;  // 慢指针，每次移动一步
    struct ListNode *fast = head->next;  // 快指针，每次移动两步
    
    // 快慢指针遍历链表
    while (fast != NULL && fast->next != NULL) {
        // 如果快慢指针相遇，说明有环
        if (slow == fast) {
            return true;
        }
        
        // 慢指针移动一步
        slow = slow->next;
        
        // 快指针移动两步
        fast = fast->next->next;
    }
    
    // 快指针到达链表末尾，说明没有环
    return false;
}
```

### C++ 实现

```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
        // 边界条件：空链表或单节点链表
        if (head == NULL || head->next == NULL) {
            return false;
        }
        
        // 初始化快慢指针
        ListNode *slow = head;  // 慢指针，每次移动一步
        ListNode *fast = head->next;  // 快指针，每次移动两步
        
        // 快慢指针遍历链表
        while (fast != NULL && fast->next != NULL) {
            // 如果快慢指针相遇，说明有环
            if (slow == fast) {
                return true;
            }
            
            // 慢指针移动一步
            slow = slow->next;
            
            // 快指针移动两步
            fast = fast->next->next;
        }
        
        // 快指针到达链表末尾，说明没有环
        return false;
    }
};
```

### 另一种初始化方式（都从 head 开始）

```c
bool hasCycle(struct ListNode *head) {
    if (head == NULL) {
        return false;
    }
    
    struct ListNode *slow = head;
    struct ListNode *fast = head;
    
    // 注意：这里需要先移动再判断，避免初始时 slow == fast
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
        
        if (slow == fast) {
            return true;
        }
    }
    
    return false;
}
```

**两种方式的区别**：
- 方式一：`fast` 从 `head->next` 开始，避免初始时 `slow == fast` 的误判
- 方式二：都从 `head` 开始，但需要先移动再判断

两种方式都是正确的，方式一更直观。

---

## 复杂度分析

### 时间复杂度：O(n)

- `n` 是链表的长度
- 最坏情况下，快指针需要遍历整个链表才能确定是否有环
- 如果存在环，快慢指针最多需要 `C` 步相遇（`C` 是环的长度）
- 如果不存在环，快指针需要 `n/2` 步到达末尾

### 空间复杂度：O(1)

- 只使用了两个指针变量 `slow` 和 `fast`
- 没有使用额外的数据结构
- 符合进阶要求

---

## 常见错误

1. **边界条件处理不当**
   - 忘记处理空链表：`if (head == NULL) return false;`
   - 忘记处理单节点链表：`if (head->next == NULL) return false;`

2. **快指针移动错误**
   - 错误：`fast = fast->next;`（只移动一步）
   - 正确：`fast = fast->next->next;`（移动两步）
   - 注意：需要先检查 `fast != NULL && fast->next != NULL`

3. **空指针访问**
   - 错误：`fast = fast->next->next;` 前没有检查 `fast->next`
   - 正确：先检查 `fast != NULL && fast->next != NULL`

4. **初始条件错误**
   - 错误：`slow = head; fast = head;` 然后立即判断 `if (slow == fast) return true;`
   - 问题：初始时 `slow == fast`，会误判为有环
   - 解决：`fast` 从 `head->next` 开始，或先移动再判断

5. **使用哈希表（不符合进阶要求）**
   - 虽然可以解决问题，但空间复杂度是 O(n)
   - 不符合 O(1) 空间复杂度的要求

---

## 扩展思考

### 1. 进阶问题：找环的入口（LeetCode 142）

**问题描述：**  
不仅判断是否有环，还要找到环的入口节点。

**思路**：
1. 使用快慢指针找到相遇点
2. 将一个指针重置到 `head`，两个指针同时每次移动一步
3. 再次相遇的点就是环的入口

**数学原理**：
- 假设从链表头到环入口的距离为 `a`
- 从环入口到相遇点的距离为 `b`
- 从相遇点到环入口的距离为 `c`
- 慢指针走的距离：`a + b`
- 快指针走的距离：`a + b + n * (b + c)`（n 是快指针在环中多走的圈数）
- 由于快指针速度是慢指针的 2 倍：`2(a + b) = a + b + n(b + c)`
- 化简得：`a = (n - 1)(b + c) + c`
- 这意味着：从链表头到环入口的距离 = 从相遇点到环入口的距离 + (n-1) 圈

**代码实现**：

```c
struct ListNode *detectCycle(struct ListNode *head) {
    if (head == NULL || head->next == NULL) {
        return NULL;
    }
    
    // 第一步：找到相遇点
    struct ListNode *slow = head;
    struct ListNode *fast = head;
    
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
        
        if (slow == fast) {
            // 找到相遇点，进入第二步
            break;
        }
    }
    
    // 如果没有相遇，说明没有环
    if (fast == NULL || fast->next == NULL) {
        return NULL;
    }
    
    // 第二步：找环的入口
    slow = head;  // 重置到链表头
    while (slow != fast) {
        slow = slow->next;
        fast = fast->next;
    }
    
    return slow;  // 环的入口
}
```

### 2. 相关题目

- **142. 环形链表 II**（找环的入口）
  在本题基础上，需要找到环的入口节点

- **202. 快乐数**  
  使用快慢指针检测循环（不是链表，但原理相同）

- **876. 链表的中间结点**  
  使用快慢指针找链表的中间节点

### 3. 其他检测环的方法

#### 方法一：哈希表（不符合进阶要求）

```c
bool hasCycle(struct ListNode *head) {
    struct ListNode *visited[10000] = {0};  // 简化示例，实际应使用哈希表
    int count = 0;
    
    struct ListNode *curr = head;
    while (curr != NULL) {
        // 检查当前节点是否已访问
        for (int i = 0; i < count; i++) {
            if (visited[i] == curr) {
                return true;  // 找到重复节点，有环
            }
        }
        
        // 将当前节点加入已访问列表
        visited[count++] = curr;
        curr = curr->next;
    }
    
    return false;
}
```

**复杂度**：
- 时间复杂度：O(n²)（每次都要遍历已访问列表）
- 空间复杂度：O(n)

#### 方法二：标记节点（不符合题目要求）

```c
bool hasCycle(struct ListNode *head) {
    struct ListNode *curr = head;
    while (curr != NULL) {
        if (curr->val == INT_MAX) {  // 使用特殊值标记
            return true;  // 已访问过，有环
        }
        curr->val = INT_MAX;  // 标记为已访问
        curr = curr->next;
    }
    return false;
}
```

**问题**：修改了链表节点的值，不符合题目要求。

### 4. 快慢指针的其他应用

- **找链表的中间节点**：快指针到达末尾时，慢指针在中间
- **找链表的倒数第 k 个节点**：快指针先走 k 步，然后两个指针同时移动
- **判断链表是否为回文链表**：快慢指针找中点，然后反转后半部分

---

**总结：** 本题是快慢指针（Floyd判圈算法）的经典应用，核心思想是使用两个指针以不同速度遍历链表，如果存在环，快指针最终会追上慢指针。掌握本题后，可以轻松解决类似的链表问题。👍

