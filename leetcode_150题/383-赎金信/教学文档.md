# LeetCode 383. 赎金信 - 详细教学文档

## 📚 目录

1. [问题分析](#问题分析)
2. [思路解析](#思路解析)
3. [算法详解](#算法详解)
4. [代码实现](#代码实现)
5. [复杂度分析](#复杂度分析)
6. [常见错误](#常见错误)
7. [扩展思考](#扩展思考)

---

## 问题分析

### 题目要求

- 输入两个字符串 `ransomNote` 和 `magazine`
- 判断赎金信是否能完全由杂志中的字符构成
- 杂志中的每个字符最多使用一次
- 仅包含小写英文字母

### 关键约束

1. 字符长度可达 `10^5`，需要 O(n) 级别解法
2. 仅包含 `'a'` 到 `'z'`，可用固定长度 26 的计数数组
3. 如果 `ransomNote` 比 `magazine` 长，必然返回 `false`

---

## 思路解析

### 错误直觉 ❌

1. **暴力逐字符删除**  
   - 对于 `ransomNote` 中的每个字符，在 `magazine` 里查找并删除一次  
   - 需要频繁移动或标记，时间复杂度可能达到 O(n²)

2. **排序后双指针**  
   - 排序会破坏“字符只能使用一次”的本质顺序约束，但更麻烦的是排序本身需要 O(n log n) 时间

3. **使用哈希表但未初始化**  
   - 在 C 语言中如果忘记将计数数组初始化为 0，结果会受到栈内垃圾值影响

### 正确思路 ✅

最直接可靠的方法是 **计数数组（频次统计）**：

1. 遍历 `magazine`，统计每个字母的出现次数
2. 遍历 `ransomNote`，逐个消耗对应字母的库存
3. 如果某个字母库存小于 0，立即返回 `false`
4. 全部消耗完成则返回 `true`

伪代码：

```
count[26] = {0}
for ch in magazine:
    count[ch - 'a']++

for ch in ransomNote:
    count[ch - 'a']--
    if count[...] < 0:
        return false

return true
```

---

## 算法详解

1. **初始化计数数组**
   - 使用 `int count[26] = {0};` 将所有元素置零

2. **统计 magazine**
   - 遍历 `magazine` 的每一个字符 `ch`
   - 计算索引 `idx = ch - 'a'`
   - 执行 `count[idx]++`

3. **校验 ransomNote**
   - 遍历 `ransomNote`，同样计算索引
   - 每出现一次字符，执行 `count[idx]--`
   - 若 `count[idx] < 0`，说明 `magazine` 中该字符数量不足，返回 `false`

4. **返回结果**
   - 如果循环结束都没有库存不足，说明可以构造赎金信，返回 `true`

### 为什么可行？

- 每个字符最多使用一次 ⇒ 计数数组正好记录“剩余库存”
- 字母范围固定 ⇒ 计数数组长度固定为 26，空间 O(1)
- 一次统计 + 一次校验 ⇒ 总时间 O(n)

---

## 代码实现

### C 语言实现

```c
bool canConstruct(char* ransomNote, char* magazine) {
    int count[26] = {0};  // 计数数组

    for (int i = 0; magazine[i] != '\0'; i++) {
        int idx = magazine[i] - 'a';
        count[idx]++;
    }

    for (int i = 0; ransomNote[i] != '\0'; i++) {
        int idx = ransomNote[i] - 'a';
        count[idx]--;
        if (count[idx] < 0) {
            return false;
        }
    }

    return true;
}
```

### C++ 实现

```cpp
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int count[26] = {0};

        for (char ch : magazine) {
            count[ch - 'a']++;
        }

        for (char ch : ransomNote) {
            int idx = ch - 'a';
            count[idx]--;
            if (count[idx] < 0) {
                return false;
            }
        }

        return true;
    }
};
```

---

## 复杂度分析

- **时间复杂度：** O(n + m)  
  其中 `n = ransomNote.length`，`m = magazine.length`，两次线性遍历

- **空间复杂度：** O(1)  
  计数数组长度固定为 26，与输入规模无关

---

## 常见错误

1. **计数数组未初始化**  
   - 栈内垃圾值会导致随机正负数，需使用 `{0}` 或 `memset`

2. **数组越界**  
   - 出现非小写字母时需要防守（本题已限制字母范围，但多加断言更稳）

3. **重复统计 ransomNote**  
   - 只需要一次遍历 magazine，一次遍历 ransomNote，不要在每次循环中重新统计

4. **字符差值写反**  
   - `ch - 'a'` 而非 `'a' - ch`，否则索引变负数

5. **提前返回条件缺失**  
   - 当 `count[idx] < 0` 时应立即返回，避免无效遍历

---

## 扩展思考

1. **如果字符集包含大小写或更多符号？**  
   - 可换成 `unordered_map<char, int>` 或 `vector<int>(128, 0)`

2. **如果 magazine 非常大，如何节省空间？**  
   - 仍可用 26 数组；若字符范围更大，可采用滑动窗口 + 差分统计

3. **与 242 题《有效的字母异位词》的联系**  
   - 同样是统计 A 和 B 的字符差异，区别在于本题只要求 magazine 能覆盖 ransomNote

4. **如何处理流式输入？**  
   - 可以边读取 `magazine` 边统计，再读取 `ransomNote` 消耗

---

掌握计数数组技巧后，面对各种“字母出现次数比较”的题目都能迅速下手。记得在编码时保持数组初始化、索引计算与提前返回的严谨性。💪


