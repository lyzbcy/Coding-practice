# 383. 赎金信

题目来源：https://leetcode.cn/problems/ransom-note/

---

## 📝 题目描述

给你两个只包含小写字母的字符串 `ransomNote` 和 `magazine`，判断 `ransomNote` 能否由 `magazine` 中的字符构成。

- `magazine` 中的每个字符最多使用一次
- 如果可以构成，返回 `true`；否则返回 `false`

---

## ✅ 输出规范

- 函数返回值：布尔值，`true` 表示可以构成赎金信
- 不需要修改原字符串
- 允许 `ransomNote` 与 `magazine` 长度不同

---

## 🔢 示例

### 示例 1

**输入：**  
`ransomNote = "a"`, `magazine = "b"`

**输出：**  
`false`

**解释：**  
`magazine` 中没有字母 `a`，无法构成赎金信。

---

### 示例 2

**输入：**  
`ransomNote = "aa"`, `magazine = "ab"`

**输出：**  
`false`

**解释：**  
`magazine` 中只有一个 `a`，无法组成两个 `a`。

---

### 示例 3

**输入：**  
`ransomNote = "aa"`, `magazine = "aab"`

**输出：**  
`true`

**解释：**  
`magazine` 中包含两个 `a` 和一个 `b`，足够构成赎金信。

---

## 📌 提示 / 约束

- `1 <= ransomNote.length, magazine.length <= 10^5`
- 两个字符串均由小写英文字母组成
- 题目保证输入为 ASCII 字符，不需要额外处理大小写

---

## 💡 评测流程 / 伪代码

评测机会按照以下流程验证你的代码：

```c
char* ransomNote = "...";
char* magazine = "...";
bool ok = canConstruct(ransomNote, magazine);
assert(ok == expected);
```

参考伪代码（计数数组）：

```
count[26] = {0}
for ch in magazine:
    count[ch - 'a']++

for ch in ransomNote:
    count[ch - 'a']--
    if count[...] < 0:
        return false

return true
```

---

目标：在 O(n) 时间、O(1) 额外空间内完成判断，并确保计数数组在使用前已初始化为 0。


