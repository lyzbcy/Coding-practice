## 初次提交代码

### 学生提交的代码

```c
int maxProfit(int* prices, int pricesSize) {
    int moneymax = 0;
    for(int i=0;i<pricesSize-1;i++){
        if(prices[i+1]-prices[i]>0){
            moneymax+=prices[i+1]-prices[i];
        }
    }
    return moneymax;
}
```

---

## 批阅意见

### ✅ 优点

1. **算法思路完全正确**：你完美理解了贪心算法的核心思想！这是解决本题的最优解法
2. **代码简洁优雅**：代码非常简洁，逻辑清晰，易于理解
3. **时间复杂度最优**：O(n)，只需要一次遍历
4. **空间复杂度最优**：O(1)，只使用了一个变量
5. **贪心策略正确**：只要后一天价格比前一天高，就进行交易，这样可以捕获所有上涨区间

### 🎯 核心思想解析

你的代码体现了经典的**贪心算法**思想：

**关键洞察**：在可以多次交易的情况下，最优策略是**捕获所有的上涨区间**。

#### 为什么这个策略是正确的？

假设价格序列为 `[1, 3, 5]`：
- **策略一（你的方法）**：第1天买入(1)，第2天卖出(3)，利润=2；第2天买入(3)，第3天卖出(5)，利润=2；总利润=4
- **策略二（只交易一次）**：第1天买入(1)，第3天卖出(5)，利润=4

**结论**：两种策略的利润相同！这是因为：
- 如果价格连续上涨，多次交易的总利润 = 一次交易的总利润
- 如果价格有波动，多次交易可以避免在下跌时持有股票

#### 数学证明

对于任意连续上涨区间 `[a, b, c, ..., z]`（a < b < c < ... < z）：
- **多次交易**：`(b-a) + (c-b) + ... + (z-y) = z - a`
- **一次交易**：`z - a`

两者相等！所以你的贪心策略是最优的。

---

### 💡 代码分析

你的代码逻辑：

```c
for(int i=0; i<pricesSize-1; i++) {
    if(prices[i+1] - prices[i] > 0) {  // 如果后一天价格更高
        moneymax += prices[i+1] - prices[i];  // 累加利润
    }
}
```

**执行过程示例**（`prices = [7,1,5,3,6,4]`）：

| i | prices[i] | prices[i+1] | 差值 | 是否累加 | moneymax |
|---|-----------|-------------|------|---------|----------|
| 0 | 7 | 1 | -6 | ❌ | 0 |
| 1 | 1 | 5 | +4 | ✅ | 4 |
| 2 | 5 | 3 | -2 | ❌ | 4 |
| 3 | 3 | 6 | +3 | ✅ | 7 |
| 4 | 6 | 4 | -2 | ❌ | 7 |

**结果**：7 ✓（正确！）

---

### ⚠️ 可以改进的地方（非常小的优化）

你的代码已经非常优秀了！以下是一些**可选的**代码风格优化：

#### 1. **代码格式优化**（可选）

当前代码：
```c
for(int i=0;i<pricesSize-1;i++){
    if(prices[i+1]-prices[i]>0){
        moneymax+=prices[i+1]-prices[i];
    }
}
```

建议格式（更易读）：
```c
for(int i = 0; i < pricesSize - 1; i++) {
    if(prices[i+1] - prices[i] > 0) {
        moneymax += prices[i+1] - prices[i];
    }
}
```

**说明**：这只是代码风格问题，不影响功能。你的代码功能完全正确！

#### 2. **变量命名优化**（可选）

当前：`moneymax`
建议：`maxProfit` 或 `totalProfit`

**说明**：`moneymax` 也能理解，但 `maxProfit` 更符合常见命名规范。

#### 3. **边界情况处理**（可选，但你的代码已经能正确处理）

你的代码已经能正确处理边界情况：
- `pricesSize = 0`：循环不执行，返回 0 ✓
- `pricesSize = 1`：循环不执行，返回 0 ✓
- `pricesSize = 2`：循环执行一次，正确计算 ✓

**可选优化**（显式处理边界，更清晰）：
```c
int maxProfit(int* prices, int pricesSize) {
    if(pricesSize < 2) {
        return 0;
    }
    
    int maxProfit = 0;
    for(int i = 0; i < pricesSize - 1; i++) {
        if(prices[i+1] - prices[i] > 0) {
            maxProfit += prices[i+1] - prices[i];
        }
    }
    return maxProfit;
}
```

---

## 🚀 优化版本（代码风格优化）

### 版本一：保持你的思路，优化格式

```c
int maxProfit(int* prices, int pricesSize) {
    int maxProfit = 0;
    
    for(int i = 0; i < pricesSize - 1; i++) {
        if(prices[i+1] - prices[i] > 0) {
            maxProfit += prices[i+1] - prices[i];
        }
    }
    
    return maxProfit;
}
```

### 版本二：更简洁的写法（使用 max 函数）

```c
int maxProfit(int* prices, int pricesSize) {
    int maxProfit = 0;
    
    for(int i = 0; i < pricesSize - 1; i++) {
        maxProfit += (prices[i+1] > prices[i]) ? (prices[i+1] - prices[i]) : 0;
    }
    
    return maxProfit;
}
```

或者更简洁：
```c
int maxProfit(int* prices, int pricesSize) {
    int maxProfit = 0;
    
    for(int i = 0; i < pricesSize - 1; i++) {
        int diff = prices[i+1] - prices[i];
        if(diff > 0) {
            maxProfit += diff;
        }
    }
    
    return maxProfit;
}
```

**说明**：这些优化主要是代码风格，你的原始代码在功能上已经是最优的了！

---

## 📊 性能分析

| 指标 | 你的代码 | 说明 |
|------|---------|------|
| 时间复杂度 | O(n) | 一次遍历，最优 |
| 空间复杂度 | O(1) | 只使用一个变量，最优 |
| 代码行数 | 7 行 | 非常简洁 |
| 可读性 | ⭐⭐⭐⭐ | 逻辑清晰 |

**结论**：你的代码在**算法层面已经是最优解**！🎉

---

## 🎓 学习要点

### 1. **贪心算法的本质**

贪心算法的核心思想：**每一步都做出当前看起来最优的选择**。

在这道题中：
- **局部最优**：只要后一天价格更高，就进行交易
- **全局最优**：所有局部最优的选择加起来，就是全局最优解

### 2. **为什么贪心在这里是正确的？**

关键点：**可以多次交易**，所以不需要考虑"等待更好的卖出时机"。

- 如果价格连续上涨：多次交易 = 一次交易（利润相同）
- 如果价格有波动：多次交易可以避免在下跌时持有股票

### 3. **与 121 题的区别**

| 题目 | 交易次数限制 | 解法 |
|------|------------|------|
| 121 题 | 只能交易一次 | 需要找到最低买入价和最高卖出价 |
| 122 题 | 可以多次交易 | 贪心：捕获所有上涨区间 |

---

## 💭 深入思考

### 问题：为什么不能"等待更好的卖出时机"？

假设价格序列为 `[1, 3, 5, 2]`：

**策略一（你的方法）**：
- 第1天买入(1)，第2天卖出(3)，利润=2
- 第2天买入(3)，第3天卖出(5)，利润=2
- 总利润=4

**策略二（等待）**：
- 第1天买入(1)，等待...
- 第3天卖出(5)，利润=4
- 但第4天价格跌到2，如果第3天没卖，利润会减少

**结论**：在可以多次交易的情况下，不需要等待，直接捕获所有上涨区间即可。

---

## ✅ 总结

### 你的代码评价

**算法正确性**：⭐⭐⭐⭐⭐（完全正确）
**代码简洁性**：⭐⭐⭐⭐⭐（非常简洁）
**性能优化**：⭐⭐⭐⭐⭐（已经是最优解）
**代码风格**：⭐⭐⭐⭐（可以稍微优化格式，但不影响功能）

### 总体评价

你的代码**逻辑完全正确**，已经掌握了贪心算法的核心思想！这是解决本题的**最优解法**。

**建议**：
1. ✅ 保持你的算法思路（已经是最优的）
2. 💡 可以考虑优化代码格式（空格、命名等），但这只是风格问题
3. 🎯 理解为什么贪心策略在这里是正确的（你已经做到了！）

---

## 🎉 恭喜！

你的代码已经达到了**最优解**的水平！这道题的核心就是理解"可以多次交易时，贪心策略是最优的"。

继续加油！💪

---

## 批阅说明

本文件用于记录学生的代码提交和批阅意见。当学生提交代码后，老师会：

1. **分析代码逻辑**：检查算法思路是否正确
2. **检查语法错误**：查找编译错误和语法问题
3. **评估复杂度**：分析时间和空间复杂度
4. **提供改进建议**：给出优化方案和最佳实践

