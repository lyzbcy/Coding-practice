# LeetCode 209. 长度最小的子数组 - 详细教学文档

## 📚 目录

1. [问题分析](#问题分析)
2. [思路解析](#思路解析)
3. [算法详解](#算法详解)
4. [代码实现](#代码实现)
5. [复杂度分析](#复杂度分析)
6. [常见错误](#常见错误)
7. [扩展思考](#扩展思考)

---

## 问题分析

### 题目要求

- 给定一个含有 `n` 个正整数的数组 `nums` 和一个正整数 `target`
- 找出满足其总和大于等于 `target` 的**长度最小**的子数组
- 返回该子数组的长度
- 如果不存在符合条件的子数组，返回 `0`

### 关键约束

1. **子数组必须是连续的**（这是关键！）
2. 所有元素都是正整数，这保证了滑动窗口的单调性
3. `nums.length` 最多 `10^5`，需要 O(n) 或 O(n log n) 的解法
4. `target` 最大为 `10^9`，需要注意整数溢出

### 关键理解

- **子数组 vs 子序列**：
  - 子数组：必须是原数组中**连续**的元素，如 `[2,3,1]` 是 `[2,3,1,2,4,3]` 的子数组
  - 子序列：可以不连续，如 `[2,1,4]` 是 `[2,3,1,2,4,3]` 的子序列
  - 本题要求的是**子数组**，必须连续！

---

## 思路解析

### 错误直觉 ❌

1. **排序后取前 k 个最大的数**：
   - 问题：排序会破坏数组的连续性，无法保证是子数组
   - 示例：`nums = [2,3,1,2,4,3]`，排序后是 `[1,2,2,3,3,4]`
   - 取前两个 `[4,3]` 的和为 `7`，但它们在原数组中不连续！

2. **暴力枚举所有子数组**：
   - 时间复杂度 O(n²)，对于 `n = 10^5` 会超时
   - 虽然正确，但效率太低

3. **贪心：从最大元素开始累加**：
   - 问题：同样无法保证连续性
   - 即使找到满足条件的组合，也不一定是子数组

### 正确思路 ✅

本题是经典的 **滑动窗口（双指针）** 问题：

**核心思想**：
- 使用两个指针 `left` 和 `right` 维护一个窗口 `[left, right]`
- `right` 不断向右扩展，增加窗口内的元素和
- 当窗口内的元素和 `>= target` 时，尝试缩小窗口（`left` 右移），寻找更小的长度
- 在窗口缩小的过程中，记录满足条件的最小长度

**为什么可以用滑动窗口？**
- 所有元素都是正整数，保证了窗口扩展时和单调递增
- 当窗口和 `>= target` 时，继续扩展只会让和更大，不会更优
- 因此可以安全地缩小窗口，寻找更小的长度

---

## 算法详解

### 滑动窗口算法流程

1. **初始化**：
   - `left = 0`，`right = 0`
   - `sum = 0`（当前窗口的元素和）
   - `minLen = INT_MAX`（记录最小长度）

2. **扩展窗口**（`right` 右移）：
   - 将 `nums[right]` 加入窗口：`sum += nums[right]`
   - `right++`

3. **收缩窗口**（`left` 右移）：
   - 当 `sum >= target` 时：
     - 更新最小长度：`minLen = min(minLen, right - left)`
     - 尝试缩小窗口：`sum -= nums[left]`，`left++`
   - 重复步骤 3，直到 `sum < target`

4. **重复步骤 2-3**，直到 `right` 到达数组末尾

5. **返回结果**：
   - 如果 `minLen == INT_MAX`，返回 `0`（未找到）
   - 否则返回 `minLen`

### 伪代码

```
minSubArrayLen(target, nums):
    left = 0
    sum = 0
    minLen = INT_MAX
    
    for right in range(len(nums)):
        sum += nums[right]  // 扩展窗口
        
        while sum >= target:  // 尝试缩小窗口
            minLen = min(minLen, right - left + 1)
            sum -= nums[left]
            left++
    
    return minLen == INT_MAX ? 0 : minLen
```

### 示例演示

以 `target = 7`, `nums = [2,3,1,2,4,3]` 为例：

| 步骤 | left | right | 窗口 | sum | minLen | 操作 |
|------|------|-------|------|-----|--------|------|
| 初始 | 0 | 0 | [2] | 2 | ∞ | 扩展 |
| 1 | 0 | 1 | [2,3] | 5 | ∞ | 扩展 |
| 2 | 0 | 2 | [2,3,1] | 6 | ∞ | 扩展 |
| 3 | 0 | 3 | [2,3,1,2] | 8 | 4 | sum>=7，更新minLen=4，缩小 |
| 4 | 1 | 3 | [3,1,2] | 6 | 4 | sum<7，扩展 |
| 5 | 1 | 4 | [3,1,2,4] | 10 | 4 | sum>=7，更新minLen=4，缩小 |
| 6 | 2 | 4 | [1,2,4] | 7 | 3 | sum>=7，更新minLen=3，缩小 |
| 7 | 3 | 4 | [2,4] | 6 | 3 | sum<7，扩展 |
| 8 | 3 | 5 | [2,4,3] | 9 | 3 | sum>=7，更新minLen=3，缩小 |
| 9 | 4 | 5 | [4,3] | 7 | 2 | sum>=7，更新minLen=2，缩小 |
| 10 | 5 | 5 | [3] | 3 | 2 | sum<7，结束 |

最终返回 `minLen = 2`。

---

## 代码实现

### C 语言实现

```c
int minSubArrayLen(int target, int* nums, int numsSize) {
    int left = 0;
    int sum = 0;
    int minLen = INT_MAX;
    
    for (int right = 0; right < numsSize; right++) {
        // 扩展窗口：将 nums[right] 加入窗口
        sum += nums[right];
        
        // 收缩窗口：当 sum >= target 时，尝试缩小窗口
        while (sum >= target) {
            // 更新最小长度
            int currentLen = right - left + 1;
            if (currentLen < minLen) {
                minLen = currentLen;
            }
            
            // 缩小窗口：移除 nums[left]
            sum -= nums[left];
            left++;
        }
    }
    
    // 如果未找到满足条件的子数组，返回 0
    return minLen == INT_MAX ? 0 : minLen;
}
```

### C++ 实现

```cpp
#include <algorithm>
#include <climits>

class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int left = 0;
        int sum = 0;
        int minLen = INT_MAX;
        
        for (int right = 0; right < nums.size(); right++) {
            // 扩展窗口
            sum += nums[right];
            
            // 收缩窗口
            while (sum >= target) {
                minLen = min(minLen, right - left + 1);
                sum -= nums[left];
                left++;
            }
        }
        
        return minLen == INT_MAX ? 0 : minLen;
    }
};
```

### 关键点说明

1. **为什么用 `while` 而不是 `if`？**
   - 因为缩小窗口后，可能仍然满足 `sum >= target`
   - 需要继续缩小，直到 `sum < target`

2. **为什么 `right - left + 1` 是窗口长度？**
   - `right` 和 `left` 都是闭区间索引
   - 窗口包含 `nums[left]` 到 `nums[right]`，共 `right - left + 1` 个元素

3. **边界处理**：
   - 如果 `minLen == INT_MAX`，说明未找到满足条件的子数组，返回 `0`

---

## 复杂度分析

### 时间复杂度

- **O(n)**：每个元素最多被 `left` 和 `right` 各访问一次
  - `right` 从 `0` 到 `n-1`，共 `n` 次
  - `left` 最多从 `0` 到 `n-1`，共 `n` 次
  - 总时间复杂度：O(n)

### 空间复杂度

- **O(1)**：只使用了常数额外空间（`left`、`right`、`sum`、`minLen`）

---

## 常见错误

### 错误 1：混淆子数组和子序列

**错误代码**：
```c
// 排序后取前 k 个最大的数
qsort(nums, numsSize, sizeof(int), compare);
int sum = 0;
for (int i = 0; i < numsSize; i++) {
    sum += nums[i];
    if (sum >= target) {
        return i + 1;
    }
}
```

**问题**：排序会破坏数组的连续性，无法保证是子数组。

**正确做法**：使用滑动窗口，保证窗口内的元素在原数组中连续。

### 错误 2：使用 `if` 而不是 `while` 来缩小窗口

**错误代码**：
```c
if (sum >= target) {
    minLen = min(minLen, right - left + 1);
    sum -= nums[left];
    left++;
}
```

**问题**：缩小窗口后可能仍然满足条件，需要继续缩小。

**正确做法**：使用 `while` 循环，直到 `sum < target`。

### 错误 3：窗口长度计算错误

**错误代码**：
```c
minLen = min(minLen, right - left);  // 错误：应该是 right - left + 1
```

**问题**：`right - left` 是元素个数减 1，不是窗口长度。

**正确做法**：使用 `right - left + 1`。

### 错误 4：未处理未找到的情况

**错误代码**：
```c
return minLen;  // 如果未找到，minLen 仍然是 INT_MAX
```

**问题**：如果未找到满足条件的子数组，`minLen` 仍然是 `INT_MAX`，应该返回 `0`。

**正确做法**：返回 `minLen == INT_MAX ? 0 : minLen`。

---

## 扩展思考

### 进阶：O(n log n) 解法

使用**前缀和 + 二分查找**：

1. 计算前缀和数组 `prefix[i] = nums[0] + nums[1] + ... + nums[i-1]`
2. 对于每个位置 `i`，使用二分查找找到最小的 `j`，使得 `prefix[j] - prefix[i] >= target`
3. 更新最小长度

**时间复杂度**：O(n log n)  
**空间复杂度**：O(n)

### 相关题目

1. **3. 无重复字符的最长子串**：滑动窗口，维护无重复字符的窗口
2. **76. 最小覆盖子串**：滑动窗口，维护包含目标字符串的窗口
3. **904. 水果成篮**：滑动窗口，维护最多两种水果的窗口
4. **30. 串联所有单词的子串**：滑动窗口的变种

### 思考题

1. 如果数组中有负数，滑动窗口还适用吗？为什么？
2. 如果要求的是子序列而不是子数组，应该用什么方法？
3. 如果要求的是所有满足条件的子数组，而不是最小长度，应该怎么修改？

---

**总结**：滑动窗口是解决"连续子数组"问题的经典技巧，关键在于理解窗口扩展和收缩的条件。



