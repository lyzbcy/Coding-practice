## 初次提交代码

```c
int minSubArrayLen(int target, int* nums, int numsSize) {
   /*
    思路：先进行递增排序，每找到一个最大数，就把最大数加到sum里面，遍历数组，如果中间发现sum>=target,return长度
    否则遍历完后return 0 
   */ 
   int sum=0;
   for(int i=0;i<numsSize;i++){
    int max=nums[i];
    int max_num=i;
    for(int j=i;j<numsSize;j++){
        if(nums[j]>max){
            max=nums[j];
            max_num=j;
        }
    }
    int zancun=nums[i];
    nums[i]=max;
    nums[max_num]=zancun;
    sum+=max;
    if(sum>=target){
        return i+1;
    }
   }
   return 0;
}
```

## 批阅意见

### ✅ 优点

1. **基本思路理解**：你理解了需要找到满足条件的子数组，并且知道需要累加元素
2. **边界处理**：代码中考虑了未找到的情况，返回 `0`
3. **变量命名**：使用了有意义的变量名（如 `sum`、`max`）

### ❌ 问题分析

#### 1. **混淆了子数组和子序列（核心错误）**

**问题**：题目要求的是**子数组**（必须是连续的），但你的代码通过排序破坏了数组的连续性。

**错误代码逻辑：**
```c
// 你的代码：选择排序，每次找最大值
for(int i=0;i<numsSize;i++){
    // 找最大值并交换到位置 i
    // 然后累加
    sum+=max;
    if(sum>=target){
        return i+1;  // 返回的是排序后的前 i+1 个元素
    }
}
```

**问题分析**：
- 题目要求：**子数组必须是连续的**，如 `[2,3,1,2,4,3]` 中，`[2,3,1]` 是子数组，但 `[4,3]` 在原数组中不连续（中间有 `2`）
- 你的做法：排序后取前 k 个最大的数，但这些数在原数组中**不一定是连续的**
- **示例验证**：
  - 输入：`target = 7`, `nums = [2,3,1,2,4,3]`
  - 你的代码排序后：`[4,3,3,2,2,1]`
  - 取前 2 个：`[4,3]`，和为 `7`，返回 `2`
  - 但 `[4,3]` 在原数组中不连续！正确答案应该是 `[4,3]`（在原数组中连续），但你的算法无法保证这一点

**正确理解**：
- **子数组**：必须是原数组中连续的元素，如 `[2,3,1]` 是 `[2,3,1,2,4,3]` 的子数组
- **子序列**：可以不连续，如 `[2,1,4]` 是 `[2,3,1,2,4,3]` 的子序列
- 本题要求的是**子数组**，必须连续！

---

#### 2. **时间复杂度问题**

**问题**：你的代码使用了选择排序，时间复杂度为 O(n²)，对于 `n = 10^5` 会超时。

**错误代码：**
```c
for(int i=0;i<numsSize;i++){
    // 选择排序：每次找最大值
    for(int j=i;j<numsSize;j++){
        if(nums[j]>max){
            max=nums[j];
            max_num=j;
        }
    }
    // 交换
    // ...
}
```

**问题分析**：
- 外层循环：O(n)
- 内层循环：O(n)
- 总时间复杂度：O(n²)
- 对于 `n = 10^5`，会超时

**正确做法**：使用滑动窗口，时间复杂度 O(n)。

---

#### 3. **修改了原数组**

**问题**：你的代码通过排序修改了原数组，这不符合题目要求（虽然题目没有明确禁止，但通常不应该修改输入数组）。

**错误代码：**
```c
int zancun=nums[i];
nums[i]=max;
nums[max_num]=zancun;  // 修改了原数组
```

**问题分析**：
- 题目要求的是找到子数组，不需要修改原数组
- 修改原数组可能导致后续处理出现问题

---

#### 4. **逻辑错误：累加的是排序后的值**

**问题**：你累加的是排序后的最大值，而不是原数组中连续的子数组的和。

**错误代码：**
```c
sum+=max;  // 累加的是排序后的最大值
if(sum>=target){
    return i+1;  // 返回的是排序后的前 i+1 个元素的数量
}
```

**问题分析**：
- 你返回的是排序后前 k 个元素的数量，但这些元素在原数组中不连续
- 题目要求的是原数组中连续的子数组的长度

---

#### 5. **变量命名可以改进**

**问题**：`zancun` 是拼音，建议使用英文命名。

**错误代码：**
```c
int zancun=nums[i];  // 应该是 temp 或 temp_val
```

**建议**：使用 `temp` 或 `temp_val`。

---

### 🔍 正确解法：滑动窗口

#### 方法一：滑动窗口（推荐）

```c
int minSubArrayLen(int target, int* nums, int numsSize) {
    int left = 0;           // 窗口左边界
    int sum = 0;            // 当前窗口的元素和
    int minLen = INT_MAX;   // 记录满足条件的最小长度
    
    // 使用 right 指针扩展窗口
    for (int right = 0; right < numsSize; right++) {
        // 扩展窗口：将 nums[right] 加入窗口
        sum += nums[right];
        
        // 收缩窗口：当 sum >= target 时，尝试缩小窗口以寻找更小的长度
        while (sum >= target) {
            // 更新最小长度
            int currentLen = right - left + 1;
            if (currentLen < minLen) {
                minLen = currentLen;
            }
            
            // 缩小窗口：移除 nums[left]
            sum -= nums[left];
            left++;
        }
    }
    
    // 如果未找到满足条件的子数组，返回 0
    return minLen == INT_MAX ? 0 : minLen;
}
```

**改进点**：
1. ✅ **保证连续性**：使用滑动窗口，保证窗口内的元素在原数组中连续
2. ✅ **时间复杂度 O(n)**：每个元素最多被访问两次（`left` 和 `right` 各一次）
3. ✅ **不修改原数组**：只读取数组，不修改
4. ✅ **正确逻辑**：找到所有满足条件的连续子数组，记录最小长度

**算法流程**：
1. 初始化 `left=0`, `sum=0`, `minLen=∞`
2. `right` 从 `0` 到 `n-1`，扩展窗口：
   - 将 `nums[right]` 加入窗口：`sum += nums[right]`
3. 当 `sum >= target` 时，收缩窗口：
   - 更新最小长度：`minLen = min(minLen, right - left + 1)`
   - 移除 `nums[left]`：`sum -= nums[left]`, `left++`
   - 重复直到 `sum < target`
4. 返回 `minLen == INT_MAX ? 0 : minLen`

**为什么可以用滑动窗口？**
- 所有元素都是正整数，保证了窗口扩展时和单调递增
- 当窗口和 `>= target` 时，继续扩展只会让和更大，不会更优
- 因此可以安全地缩小窗口，寻找更小的长度

---

### 📝 总结

你的代码思路方向有误，主要问题：

1. **核心错误**：混淆了子数组和子序列，通过排序破坏了连续性
2. **时间复杂度**：O(n²) 会超时，应该使用 O(n) 的滑动窗口
3. **逻辑错误**：累加的是排序后的值，而不是原数组中连续的子数组的和
4. **修改原数组**：不应该修改输入数组

**建议**：
- 理解**子数组**和**子序列**的区别
- 学习**滑动窗口**技巧，这是解决"连续子数组"问题的经典方法
- 注意题目要求：**子数组必须是连续的**

---

**加油！滑动窗口是解决连续子数组问题的经典技巧，多练习就能掌握！** 💪



