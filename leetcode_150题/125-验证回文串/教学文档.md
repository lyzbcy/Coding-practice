# LeetCode 125. 验证回文串 - 详细教学文档

## 📚 目录

1. [问题分析](#问题分析)
2. [思路解析](#思路解析)
3. [算法详解](#算法详解)
4. [代码实现](#代码实现)
5. [复杂度分析](#复杂度分析)
6. [常见错误](#常见错误)
7. [扩展思考](#扩展思考)

---

## 问题分析

### 题目要求

- 给定一个字符串 `s`
- 需要判断在预处理后是否为回文串
- 预处理包括：
  1. 将所有大写字符转换为小写
  2. 移除所有非字母数字字符（只保留字母和数字）

### 关键约束

1. **字符串长度**：最多 `2 * 10^5`，需要 O(n) 或更优的算法
2. **字符类型**：可打印的 ASCII 字符，包括字母、数字、标点、空格等
3. **大小写不敏感**：`'A'` 和 `'a'` 视为相同
4. **只考虑字母数字**：标点符号、空格等需要忽略

---

## 思路解析

### 错误直觉 ❌

- **先构建新字符串再判断**：虽然直观，但需要额外 O(n) 空间
- **使用栈或反转字符串**：空间复杂度较高，不符合最优解要求
- **忘记处理大小写**：直接比较 `'A'` 和 `'a'` 会得到错误结果
- **忘记过滤非字母数字字符**：标点符号会影响判断

### 正确思路 ✅

本题有两种主要解法：

#### 方法一：预处理 + 双指针（推荐）

1. **预处理阶段**：构建只包含字母数字的新字符串，并转为小写
2. **判断阶段**：使用双指针从两端向中间比较

#### 方法二：原地双指针（空间最优）

1. **边过滤边比较**：使用双指针，遇到非字母数字字符时跳过
2. **同时处理大小写**：比较时统一转为小写

伪代码（方法二，空间最优）：

```
left = 0
right = len(s) - 1

while left < right:
    // 跳过非字母数字字符
    while left < right and not isalnum(s[left]):
        left++
    while left < right and not isalnum(s[right]):
        right--
    
    // 比较字符（转小写）
    if tolower(s[left]) != tolower(s[right]):
        return false
    
    left++
    right--

return true
```

---

## 算法详解

### 方法一：预处理 + 双指针

1. **预处理字符串**
   - 遍历原字符串，筛选出字母数字字符
   - 将所有字符转为小写
   - 构建新字符串

2. **双指针比较**
   - `left = 0`，`right = len(新字符串) - 1`
   - 每次比较 `s[left]` 和 `s[right]`
   - 如果相等，`left++`，`right--`
   - 如果不相等，返回 `false`
   - 当 `left >= right` 时，返回 `true`

### 方法二：原地双指针（推荐）

1. **初始化指针**
   - `left = 0`：从左侧开始
   - `right = len(s) - 1`：从右侧开始

2. **循环比较**
   - **跳过非字母数字字符**：
     - 如果 `s[left]` 不是字母数字，`left++`
     - 如果 `s[right]` 不是字母数字，`right--`
   - **比较字符**：
     - 将 `s[left]` 和 `s[right]` 转为小写后比较
     - 如果不等，返回 `false`
     - 如果相等，`left++`，`right--`

3. **结束条件**
   - 当 `left >= right` 时，说明所有对应字符都匹配，返回 `true`

### 为什么方法二更好？

- **空间复杂度**：O(1) vs O(n)
- **时间复杂度**：都是 O(n)，但方法二只需要一次遍历
- **实际性能**：方法二避免了构建新字符串的开销

---

## 代码实现

### C 语言核心代码（方法二，推荐）

```c
#include <ctype.h>

bool isPalindrome(char* s) {
    int left = 0;
    int right = strlen(s) - 1;
    
    while (left < right) {
        // 跳过非字母数字字符
        while (left < right && !isalnum(s[left])) {
            left++;
        }
        while (left < right && !isalnum(s[right])) {
            right--;
        }
        
        // 比较字符（转小写）
        if (tolower(s[left]) != tolower(s[right])) {
            return false;
        }
        
        left++;
        right--;
    }
    
    return true;
}
```

### C++ 实现

```cpp
#include <cctype>
#include <string>
using namespace std;

class Solution {
public:
    bool isPalindrome(string s) {
        int left = 0;
        int right = s.length() - 1;
        
        while (left < right) {
            // 跳过非字母数字字符
            while (left < right && !isalnum(s[left])) {
                left++;
            }
            while (left < right && !isalnum(s[right])) {
                right--;
            }
            
            // 比较字符（转小写）
            if (tolower(s[left]) != tolower(s[right])) {
                return false;
            }
            
            left++;
            right--;
        }
        
        return true;
    }
};
```

### 方法一：预处理版本（C++）

```cpp
class Solution {
public:
    bool isPalindrome(string s) {
        string filtered;
        for (char c : s) {
            if (isalnum(c)) {
                filtered += tolower(c);
            }
        }
        
        int left = 0, right = filtered.length() - 1;
        while (left < right) {
            if (filtered[left] != filtered[right]) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
};
```

---

## 复杂度分析

### 方法一：预处理 + 双指针

- **时间复杂度：** O(n)  
  预处理需要遍历一次字符串，双指针比较也需要 O(n) 时间。

- **空间复杂度：** O(n)  
  需要额外的字符串存储预处理结果。

### 方法二：原地双指针（推荐）

- **时间复杂度：** O(n)  
  每个字符最多被访问一次（跳过非字母数字字符时可能重复访问，但总体仍是 O(n)）。

- **空间复杂度：** O(1)  
  只使用两个指针变量，属于常数额外空间。

---

## 常见错误

1. **忘记处理大小写**  
   直接比较 `'A'` 和 `'a'` 会得到错误结果，必须统一转为小写。

2. **忘记过滤非字母数字字符**  
   标点符号、空格等会影响判断，必须跳过。

3. **边界条件处理不当**  
   - 空字符串应返回 `true`
   - 只有非字母数字字符的字符串也应返回 `true`
   - 单个字母数字字符应返回 `true`

4. **指针越界**  
   在跳过非字母数字字符时，必须检查 `left < right`，否则可能越界。

5. **使用错误的字符判断函数**  
   - 应使用 `isalnum()` 判断字母数字
   - 不要用 `isalpha()`（会排除数字）或 `isdigit()`（会排除字母）

6. **预处理后忘记重置指针**  
   如果使用方法一，预处理后需要重新初始化 `left` 和 `right`。

---

## 扩展思考

1. **与 680 题《验证回文串 II》的联系**  
   - 680 题允许删除一个字符后再判断
   - 可以基于本题的解法进行扩展

2. **与 9 题《回文数》类似**  
   - 都是判断回文，但 9 题处理的是数字
   - 思路类似：双指针或反转后比较

3. **如何优化跳过非字母数字字符的过程？**  
   - 可以预先构建一个布尔数组标记哪些位置是字母数字
   - 但这样会增加空间复杂度，通常不必要

4. **如果要求保持原字符串不变？**  
   - 必须使用方法一（预处理），但空间复杂度会上升
   - 或者使用递归，但空间复杂度仍然是 O(n)

5. **如何处理 Unicode 字符？**  
   - 本题只涉及 ASCII，使用 `isalnum()` 和 `tolower()` 即可
   - 如果是 Unicode，需要使用更复杂的字符处理函数

---

**总结：** 本题是双指针技巧的经典应用，重点在于理解“边过滤边比较”的思路，以及正确处理大小写转换和字符过滤。掌握本题后，类似的字符串处理问题都可以触类旁通。👍

