# 题目描述

## 🔗 题目链接

[LeetCode 26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

## 🧾 正式描述

给定一个 **非递减排序** 的整数数组 `nums`，请你原地删除所有重复出现的元素，使得每个元素仅出现一次，并返回删除后数组的新长度 `k`。  
要求：保持元素的相对顺序不变，仅使用 O(1) 额外空间。

返回值 `k` 表示数组前 `k` 个位置存放了排序后的唯一元素；`k` 之后的内容可忽略。

## ✅ 判题标准

评测机会按如下伪代码验证答案（与官方一致）：

```c
int[] nums = [...];
int[] expectedNums = [...]; // 去重后的期望结果

int k = removeDuplicates(nums);

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
```

只要所有断言成立，即视为通过。

## 🧪 示例

**示例 1**

- 输入：`nums = [1,1,2]`
- 输出：`k = 2`，`nums = [1,2,_]`
- 说明：函数应返回 `2`，原数组前两个位置更新为 `1, 2`。

**示例 2**

- 输入：`nums = [0,0,1,1,1,2,2,3,3,4]`
- 输出：`k = 5`，`nums = [0,1,2,3,4,_,_,_,_,_]`
- 说明：函数返回 `5`，前五个元素依次为唯一值，剩余位置无需关心。

## 📏 约束

- `1 <= nums.length <= 3 * 10^4`
- `-100 <= nums[i] <= 100`
- `nums` 按非递减顺序排列

## 🧠 思路提示

1. 数组已排序，相同元素必然连续，可通过双指针一次扫描完成。
2. 维护一个「写入指针」记录下一个可填写的唯一值位置。
3. 当遇到新值时覆盖写入并右移写指针；遇到重复值直接跳过。

## 🔄 伪代码

```text
if numsSize == 0: return 0
slow = 0
for fast from 1 to numsSize - 1:
    if nums[fast] != nums[slow]:
        slow += 1
        nums[slow] = nums[fast]
return slow + 1
```

--- 

准备好后，前往 `教学文档.md` 深入理解具体实现与常见错误。***

