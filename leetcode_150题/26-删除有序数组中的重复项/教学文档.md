# 教学文档：LeetCode 26. 删除有序数组中的重复项

## 一、问题分析

- **输入特性**：数组已按非递减顺序排列，重复元素必定相邻。
- **输出目标**：原地把唯一元素依次写到数组开头，返回唯一元素数量 `k`。
- **限制条件**：O(1) 额外空间、O(n) 时间；不能创建新数组。
- **核心挑战**：一边扫描一边覆盖，既要避免遗漏新值，也要确保不会破坏尚未读取的元素。

## 二、思路解析

### 2.1 常见错误直觉

1. **使用 `set` 或额外数组**：违背空间限制。
2. **遇到重复就整体后移**：导致 O(n^2)。
3. **快慢指针起点不当**：`slow` 默认为 0，却忘记 `fast` 应从 1 开始，容易访问越界或重复统计。
4. **返回 `slow` 而非 `slow + 1`**：忽略了索引与长度的差 1 关系。

### 2.2 正确思路

1. **维护不变量**：`nums[0..slow]` 始终是已去重的子数组。
2. **初始化**：若数组非空，`slow = 0` 代表首元素已在唯一集合中；`fast = 1` 从第二个元素开始扫描。
3. **判定逻辑**：当 `nums[fast] != nums[slow]` 时，发现了新值：
   - `slow++`
   - `nums[slow] = nums[fast]`
4. **遍历结束**：返回 `slow + 1` 即唯一元素数量。

## 三、算法详解

1. **边界处理**：若 `numsSize == 0` 直接返回 0（虽然题目保证最少 1 个元素，写上更安全）。
2. **循环不变量**：每轮循环前，`nums[0..slow]` 为唯一序列，`fast` 指向待判定元素。
3. **状态转移**：
   - `nums[fast] == nums[slow]`：重复，直接 `fast++`。
   - `nums[fast] != nums[slow]`：唯一，执行覆盖并同步移动 `slow`。
4. **结束条件**：`fast` 扫描至 `numsSize - 1` 后终止。
5. **返回值**：`slow + 1`，因为 `slow` 是最后一个唯一元素的索引。

### 伪代码

```text
if numsSize == 0:
    return 0
slow = 0
for fast in [1, numsSize):
    if nums[fast] != nums[slow]:
        slow += 1
        nums[slow] = nums[fast]
return slow + 1
```

## 四、代码实现

### C 语言核心片段

```c
if (numsSize == 0) {
    return 0;
}
int slow = 0;
for (int fast = 1; fast < numsSize; fast++) {
    if (nums[fast] != nums[slow]) {
        slow++;
        nums[slow] = nums[fast];
    }
}
return slow + 1;
```

### C++ 语言核心片段

```cpp
if (nums.empty()) return 0;
int slow = 0;
for (int fast = 1; fast < nums.size(); ++fast) {
    if (nums[fast] != nums[slow]) {
        nums[++slow] = nums[fast];
    }
}
return slow + 1;
```

## 五、复杂度分析

- **时间复杂度**：O(n)，每个元素最多访问一次。
- **空间复杂度**：O(1)，只使用常量级指针变量。

## 六、常见错误

1. **忘记处理空数组**：虽然数据范围允许省略，但写上更健壮。
2. **`fast` 从 0 开始**：导致 `slow` 与 `fast` 同位，发现新元素后覆盖自己，逻辑混乱。
3. **重复元素内层 while**：容易越界（比如连续自增 `fast` 却未检查上界）。
4. **返回 `slow`**：因为 `slow` 是索引，数量应为 `slow + 1`。
5. **覆盖顺序错误**：应该先 `slow++` 再写入，否则会重复写在旧位置。

## 七、扩展思考

1. **进阶版本**：`80. 删除排序数组中的重复项 II` 限制元素出现次数不超过 2，可把条件改成记录频次。
2. **值过滤问题**：`27. 移除元素` 通过条件把非目标值写在前面，与本题类似。
3. **稳定性思维**：本质属于“读指针负责遍历，写指针保持结果稳定区”。
4. **多维推广**：链表、字符串压缩、矩阵去重等，都可借鉴“扫描 + 写指针”框架。

---

下一步：配合 `动画演示.py` 观察快慢指针的细节，或直接阅读 `答案.c / 答案.cpp`。***

