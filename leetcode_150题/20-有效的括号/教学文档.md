# LeetCode 20. 有效的括号 - 详细教学文档

## 📚 目录

1. [问题分析](#问题分析)
2. [错误直觉 vs 正确思路](#错误直觉-vs-正确思路)
3. [核心算法详解](#核心算法详解)
4. [关键代码片段](#关键代码片段)
5. [伪代码](#伪代码)
6. [复杂度分析](#复杂度分析)
7. [常见错误](#常见错误)
8. [扩展思考](#扩展思考)

---

## 问题分析

### 题目要求

- 给定一个只包含括号字符的字符串 `s`
- 判断括号是否有效匹配
- 有效需满足：
  1. 左括号必须用相同类型的右括号闭合
  2. 左括号必须以正确的顺序闭合
  3. 每个右括号都有对应的左括号

### 关键约束

1. **括号类型**：三种括号 `()`、`[]`、`{}`
2. **匹配规则**：相同类型且顺序正确
3. **嵌套规则**：内层括号必须先闭合，外层才能闭合
4. 字符串长度最多 10^4，适合线性扫描

---

## 错误直觉 vs 正确思路

### 错误直觉 ❌

1. **仅统计左右括号数量**  
   只统计每种括号的数量是否相等，无法处理顺序问题。  
   例如：`"([)]"` 中 `(` 和 `)` 数量相等，`[` 和 `]` 数量也相等，但顺序错误。

2. **使用计数器**  
   用三个计数器分别记录三种括号的未匹配数量，无法处理嵌套顺序。  
   例如：`"([)]"` 中计数器无法判断 `)` 应该匹配哪个 `(`。

3. **暴力匹配**  
   每次遇到右括号就向前查找最近的左括号，时间复杂度 O(n²) 且逻辑复杂。

### 正确思路 ✅

本题是经典的 **栈（Stack）** 应用：

- **核心思想**：后进先出（LIFO）的特性正好符合括号匹配的嵌套规则
- **匹配规则**：遇到左括号入栈，遇到右括号检查栈顶是否匹配
- **顺序保证**：栈保证了最近打开的括号最先闭合

---

## 核心算法详解

### 栈的基本操作

1. **遇到左括号**：`'('`、`'['`、`'{'` → 入栈（push）
2. **遇到右括号**：`')'`、`']'`、`'}'` → 检查栈顶是否匹配
   - 如果栈为空 → 无效（多余的右括号）
   - 如果栈顶不匹配 → 无效（类型错误）
   - 如果栈顶匹配 → 出栈（pop），继续处理

3. **遍历结束**：检查栈是否为空
   - 栈为空 → 所有括号都匹配，返回 `true`
   - 栈不为空 → 有未匹配的左括号，返回 `false`

### 匹配规则映射

为了方便判断，可以使用哈希表或数组建立映射关系：

```
')' ↔ '('
']' ↔ '['
'}' ↔ '{'
```

### 算法流程示例

以 `s = "([{}])"` 为例：

| 步骤 | 当前字符 | 栈状态 | 操作 |
|------|---------|--------|------|
| 1 | `(` | `[` | 入栈 `(` |
| 2 | `[` | `[(` | 入栈 `[` |
| 3 | `{` | `[({` | 入栈 `{` |
| 4 | `}` | `[(` | 匹配 `{`，出栈 |
| 5 | `]` | `[` | 匹配 `[`，出栈 |
| 6 | `)` | `[]` | 匹配 `(`，出栈 |
| 7 | 结束 | `[]` | 栈为空，返回 `true` |

---

## 关键代码片段

### C 语言实现要点

```c
// 使用数组模拟栈
char stack[10000];
int top = -1;  // 栈顶指针

// 匹配映射
char getMatch(char c) {
    if (c == ')') return '(';
    if (c == ']') return '[';
    if (c == '}') return '{';
    return '\0';
}

// 主逻辑
for (int i = 0; i < len; i++) {
    if (s[i] == '(' || s[i] == '[' || s[i] == '{') {
        stack[++top] = s[i];  // 左括号入栈
    } else {
        if (top < 0 || stack[top] != getMatch(s[i])) {
            return false;  // 栈为空或不匹配
        }
        top--;  // 匹配成功，出栈
    }
}
return top == -1;  // 栈为空则有效
```

### C++ 实现要点

```cpp
// 使用 STL stack
stack<char> stk;

// 匹配映射（使用哈希表）
unordered_map<char, char> pairs = {
    {')', '('},
    {']', '['},
    {'}', '{'}
};

// 主逻辑
for (char c : s) {
    if (pairs.count(c)) {  // 是右括号
        if (stk.empty() || stk.top() != pairs[c]) {
            return false;
        }
        stk.pop();
    } else {  // 是左括号
        stk.push(c);
    }
}
return stk.empty();
```

---

## 伪代码

```
函数 isValid(s):
    创建栈 stack
    创建映射 pairs: {')': '(', ']': '[', '}': '{'}
    
    遍历字符串 s 中的每个字符 c:
        如果 c 是右括号（在 pairs 中）:
            如果栈为空 或 栈顶元素 != pairs[c]:
                返回 false
            否则:
                弹出栈顶元素
        否则（c 是左括号）:
            将 c 压入栈
    
    返回 栈是否为空
```

---

## 复杂度分析

- **时间复杂度：** O(n)  
  需要遍历字符串一次，每个字符最多入栈和出栈各一次。

- **空间复杂度：** O(n)  
  最坏情况下（全是左括号），栈中需要存储 n 个元素。

---

## 常见错误

1. **忘记检查栈是否为空**  
   遇到右括号时，如果栈为空，说明没有对应的左括号，应该直接返回 `false`。

2. **匹配逻辑错误**  
   使用 `==` 直接比较而不是通过映射关系判断，容易写错匹配规则。

3. **边界条件处理不当**  
   - 空字符串应该返回 `true`（没有括号，视为有效）
   - 奇数长度字符串可以直接返回 `false`（优化，但非必需）

4. **栈顶元素判断顺序错误**  
   应该先检查栈是否为空，再访问栈顶，否则可能越界。

5. **返回条件错误**  
   遍历结束后，必须检查栈是否为空，不能直接返回 `true`。

---

## 扩展思考

1. **如何处理更多类型的括号？**  
   只需扩展映射关系，算法框架不变。例如添加 `<>`、`«»` 等。

2. **如何输出第一个不匹配的位置？**  
   在返回 `false` 时记录当前索引，可以用于错误提示。

3. **如何判断括号的嵌套深度？**  
   在遍历过程中记录栈的最大深度，即为最大嵌套层数。

4. **与 22 题《括号生成》的联系**  
   - 22 题是生成所有有效括号组合
   - 本题是验证括号是否有效
   - 都涉及括号匹配规则，但应用场景不同

5. **与 32 题《最长有效括号》的联系**  
   - 32 题需要找到最长有效括号子串
   - 可以使用栈记录索引，计算长度
   - 是本题的进阶应用

6. **优化空间复杂度？**  
   对于只有一种括号的情况，可以用计数器代替栈，空间 O(1)。  
   但本题有三种括号，必须用栈保证顺序。

---

**总结：** 本题是栈数据结构的经典入门题，重点在于理解“后进先出”特性如何自然地解决括号匹配问题。掌握本题后，类似的匹配、嵌套、递归结构问题都可以考虑使用栈来解决。👍

