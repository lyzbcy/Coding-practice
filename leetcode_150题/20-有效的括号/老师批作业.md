## 初次提交代码

```c
bool isValid(char* s) {

    char stack[100];

    int top=-1;

    for(int i=0;s[i]!='\0';i++){

        switch(s[i]){

            case('('):{

                stack[++top]=')';

            }

            case('['):{

                stack[++top]=']';

            }

            case('{'):{

                stack[++top]='}';

            }

            case(')'):{

                if(stack[top]==')'){

                    top--;

                }else{

                    return false;

                }

            }

            case(']'):{

                if(stack[top]==']'){

                    top--;

                }else{

                    return false;

                }

            }

            case('}'):{

                if(stack[top]=='}'){

                    top--;

                }else{

                    return false;

                }

            }

            default: return false;

        }

    }

    if(top<=-1){

        return true;

    }else{

        return false;

    }

}
```

## 批阅意见

1. `switch` 中每个 `case` 都缺少 `break`，导致左括号入栈后继续执行到后续分支，右括号逻辑被多次触发，流程完全错乱。  
2. 处理右括号时没有先判断 `top >= 0`，栈为空情况下访问 `stack[top]` 会越界；应当在比较前先检查。  
3. 栈容量固定为 100，而题目允许长度到 `10^4`，给较长输入会直接写越界。  
4. `default` 永远触发，因为没有 `break`，即便是合法字符也会走到 `default`；应重新组织结构并只在非括号字符时触发。  
5. 建议按照教学文档实现流程：左括号直接 `push` 并 `break`，右括号先校验栈是否为空，再比较栈顶，匹配则 `pop`，最后检查栈是否为空。

---

## 第二次提交代码

（如有第二次提交，在此填写）

## 第二次批阅意见

（如有第二次提交，在此填写）

