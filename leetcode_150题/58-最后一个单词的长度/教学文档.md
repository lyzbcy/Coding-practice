# LeetCode 58. 最后一个单词的长度 - 详细教学文档

## 📚 目录

1. [问题分析](#问题分析)
2. [思路解析](#思路解析)
3. [算法详解](#算法详解)
4. [代码实现](#代码实现)
5. [复杂度分析](#复杂度分析)
6. [常见错误](#常见错误)
7. [扩展思考](#扩展思考)

---

## 问题分析

### 题目要求

- 给定字符串 `s`，由若干单词和空格组成
- 返回最后一个单词的长度
- 单词仅由英文字母组成，不含空格
- 字符串前后可能有空格

### 关键约束

1. **字符串末尾可能有空格**，需要先跳过
2. **至少存在一个单词**，不需要处理空字符串的情况
3. 字符串长度最多 10⁴，适合线性扫描

---

## 思路解析

### 错误直觉 ❌

- **从前往后遍历，遇到空格就重置计数**：这种方法需要额外处理末尾空格，逻辑复杂
- **使用 `split` 分割字符串**：虽然简单，但需要额外空间，且不符合 O(1) 空间要求
- **先找到最后一个空格的位置**：需要两次遍历，效率较低

### 正确思路 ✅

本题最适合使用 **从后往前遍历** 的方法：

1. **跳过末尾空格**：从字符串末尾开始，跳过所有连续的空格
2. **计数最后一个单词**：从第一个非空格字符开始，向前计数直到遇到空格或字符串开头

伪代码：

```
i = s.length - 1
// 跳过末尾空格
while i >= 0 && s[i] == ' ':
    i--

// 计数最后一个单词
length = 0
while i >= 0 && s[i] != ' ':
    length++
    i--

return length
```

---

## 算法详解

1. **初始化指针**
   - `i = strlen(s) - 1`：从字符串末尾开始
   - `length = 0`：记录最后一个单词的长度

2. **跳过末尾空格**
   - 当 `i >= 0` 且 `s[i] == ' '` 时，`i--`
   - 直到找到第一个非空格字符或到达字符串开头

3. **计数最后一个单词**
   - 从当前位置开始，向前遍历
   - 每遇到一个非空格字符，`length++`，`i--`
   - 直到遇到空格或 `i < 0`

4. **返回结果**
   - `length` 即为最后一个单词的长度

### 为什么从后往前？

- **避免处理末尾空格**：从后往前可以自然地跳过末尾空格
- **只需一次遍历**：找到最后一个单词后直接计数，无需额外处理
- **逻辑清晰**：先跳过空格，再计数，步骤分明

---

## 代码实现

### C 语言核心代码

```c
int lengthOfLastWord(char* s) {
    int i = strlen(s) - 1;
    
    // 跳过末尾空格
    while (i >= 0 && s[i] == ' ') {
        i--;
    }
    
    // 计数最后一个单词的长度
    int length = 0;
    while (i >= 0 && s[i] != ' ') {
        length++;
        i--;
    }
    
    return length;
}
```

### C++（面向对象）实现

```cpp
class Solution {
public:
    int lengthOfLastWord(string s) {
        int i = s.length() - 1;
        
        // 跳过末尾空格
        while (i >= 0 && s[i] == ' ') {
            i--;
        }
        
        // 计数最后一个单词的长度
        int length = 0;
        while (i >= 0 && s[i] != ' ') {
            length++;
            i--;
        }
        
        return length;
    }
};
```

---

## 复杂度分析

- **时间复杂度：** O(n)  
  最坏情况下需要遍历整个字符串一次（跳过末尾空格 + 计数单词）。

- **空间复杂度：** O(1)  
  仅使用几个变量（`i`、`length`），属于常数额外空间。

---

## 常见错误

1. **忘记跳过末尾空格**  
   如果直接从末尾开始计数，会把末尾空格也算进去，导致结果错误。

2. **边界条件处理不当**  
   当字符串只有一个单词且前后有空格时，需要确保正确跳过空格。

3. **使用 `split` 等库函数**  
   虽然可以解决问题，但不符合 O(1) 空间复杂度的要求，且需要额外空间。

4. **从前往后遍历的复杂逻辑**  
   需要记录当前单词长度，遇到空格时判断是否重置，逻辑较复杂且容易出错。

5. **数组越界**  
   在 C 语言中，需要确保 `i >= 0` 的检查在访问 `s[i]` 之前。

---

## 扩展思考

1. **如果要求返回最后一个单词本身？**  
   可以在计数时同时记录起始位置，然后提取子字符串。

2. **如果要求返回所有单词的长度？**  
   可以使用类似方法，但需要从后往前遍历并记录每个单词的长度。

3. **与 151 题《反转字符串中的单词》的联系**  
   - 都需要处理单词和空格
   - 本题只需要最后一个单词，更简单

4. **从前往后的替代解法**  
   ```c
   int length = 0;
   for (int i = 0; s[i] != '\0'; i++) {
       if (s[i] != ' ') {
           length++;
       } else if (i + 1 < strlen(s) && s[i + 1] != ' ') {
           length = 0;  // 重置，但需要处理末尾空格
       }
   }
   ```
   这种方法需要额外处理末尾空格，不如从后往前简洁。

---

**总结：** 本题是字符串处理的经典题目，重点在于理解“从后往前遍历”的优势：可以自然地跳过末尾空格，逻辑清晰且高效。掌握本题后，类似的字符串单词处理问题都可以触类旁通。👍

