# 21. 合并两个有序链表

题目来源：https://leetcode.cn/problems/merge-two-sorted-lists/

---

## 📝 题目描述

将两个 **升序** 链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

---

## ✅ 输出规范

- 函数返回一个新的链表，表示两个输入链表合并后的结果
- 新链表同样按升序排列
- 新链表是通过拼接两个输入链表的所有节点组成的（不创建新节点，只是重新连接）
- 如果其中一个链表为空，返回另一个链表

---

## 🔢 示例

### 示例 1

**输入：**  
`l1 = [1,2,4]`, `l2 = [1,3,4]`

**输出：**  
`[1,1,2,3,4,4]`

**解释：**  
- 将两个升序链表合并
- 结果链表：1→1→2→3→4→4

---

### 示例 2

**输入：**  
`l1 = []`, `l2 = []`

**输出：**  
`[]`

**解释：**  
- 两个链表都为空
- 返回空链表

---

### 示例 3

**输入：**  
`l1 = []`, `l2 = [0]`

**输出：**  
`[0]`

**解释：**  
- l1 为空，l2 只有一个节点 0
- 返回 l2

---

## 📌 提示

- 两个链表的节点数目范围是 `[0, 50]`
- `-100 <= Node.val <= 100`
- `l1` 和 `l2` 均按 **非递减顺序** 排列

---

## 💡 评测说明

评测机会按照以下流程验证你的代码：

```c
struct ListNode* l1 = createList([1,2,4]);
struct ListNode* l2 = createList([1,3,4]);
struct ListNode* result = mergeTwoLists(l1, l2);
// 验证 result 是否等于 [1,1,2,3,4,4]
```

**目标：** 找到一种 O(m + n) 时间复杂度、O(1) 空间复杂度的解法，其中 m 和 n 分别是两个链表的长度。

---

## 🔑 关键点

1. **双指针技巧**：同时遍历两个链表，比较当前节点值
2. **选择较小值**：每次选择两个链表中当前节点值较小的那个
3. **虚拟头节点**：使用虚拟头节点可以简化边界处理
4. **处理剩余节点**：当一个链表遍历完时，直接将另一个链表的剩余部分连接上

---

