# LeetCode 21. 合并两个有序链表 - 详细教学文档

## 📚 目录

1. [问题分析](#问题分析)
2. [思路解析](#思路解析)
3. [算法详解](#算法详解)
4. [代码实现](#代码实现)
5. [复杂度分析](#复杂度分析)
6. [常见错误](#常见错误)
7. [扩展思考](#扩展思考)

---

## 问题分析

### 题目要求

- 给定两个**升序**链表
- 将它们合并为一个新的**升序**链表
- 新链表通过拼接两个输入链表的所有节点组成（不创建新节点，只是重新连接）

### 关键约束

1. **链表可能为空**：两个链表都可能为空
2. **节点值范围**：-100 ≤ Node.val ≤ 100
3. **升序排列**：两个链表都是非递减顺序
4. **节点数量**：0 ≤ 节点数 ≤ 50

### 示例理解

以示例 1 为例：
- `l1 = [1,2,4]`（升序）
- `l2 = [1,3,4]`（升序）
- 合并后：`[1,1,2,3,4,4]`（升序）

---

## 思路解析

### 错误直觉 ❌

1. **先转换为数组再合并**：
   - 问题：题目要求返回链表，且空间复杂度应该是 O(1)
   - 转换为数组需要额外空间

2. **创建新节点**：
   - 问题：题目要求通过拼接节点组成，不需要创建新节点
   - 创建新节点会增加空间复杂度

3. **先合并再排序**：
   - 问题：两个链表已经有序，不需要排序
   - 排序会增加时间复杂度

### 正确思路 ✅

本题的核心是**双指针合并**，类似于归并排序中的合并过程：

1. **同时遍历两个链表**，使用两个指针分别指向两个链表的当前节点
2. **比较当前节点值**，选择较小的节点
3. **将较小节点连接到结果链表**
4. **移动指针**到下一个节点
5. **处理剩余节点**：当一个链表遍历完时，直接将另一个链表的剩余部分连接上

伪代码：

```
dummy = 新节点（虚拟头节点）
current = dummy

while list1 != NULL 且 list2 != NULL:
    if list1->val <= list2->val:
        current->next = list1
        list1 = list1->next
    else:
        current->next = list2
        list2 = list2->next
    current = current->next

// 处理剩余节点
if list1 != NULL:
    current->next = list1
else:
    current->next = list2

return dummy->next
```

---

## 算法详解

### 步骤 1：初始化

- 创建虚拟头节点 `dummy`，简化边界处理
- 初始化 `current` 指向 `dummy`（用于构建结果链表）

### 步骤 2：同时遍历两个链表

循环条件：`list1 != NULL && list2 != NULL`

- 比较 `list1->val` 和 `list2->val`
- 选择较小的节点，连接到结果链表
- 移动对应链表的指针

### 步骤 3：处理剩余节点

当一个链表遍历完时：
- 直接将另一个链表的剩余部分连接到结果链表
- 因为剩余部分已经是有序的，不需要再处理

### 步骤 4：返回结果

返回 `dummy->next`（跳过虚拟头节点）

---

## 代码实现

### C 语言核心代码

```c
struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {
    // 创建虚拟头节点，简化边界处理
    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));
    dummy->val = 0;
    dummy->next = NULL;
    
    struct ListNode* current = dummy;
    
    // 同时遍历两个链表
    while (list1 != NULL && list2 != NULL) {
        // 选择较小的节点
        if (list1->val <= list2->val) {
            current->next = list1;
            list1 = list1->next;
        } else {
            current->next = list2;
            list2 = list2->next;
        }
        current = current->next;
    }
    
    // 处理剩余节点
    if (list1 != NULL) {
        current->next = list1;
    } else {
        current->next = list2;
    }
    
    return dummy->next;
}
```

### C++ 实现

```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        // 创建虚拟头节点
        ListNode* dummy = new ListNode(0);
        ListNode* current = dummy;
        
        // 同时遍历两个链表
        while (list1 != nullptr && list2 != nullptr) {
            if (list1->val <= list2->val) {
                current->next = list1;
                list1 = list1->next;
            } else {
                current->next = list2;
                list2 = list2->next;
            }
            current = current->next;
        }
        
        // 处理剩余节点
        current->next = (list1 != nullptr) ? list1 : list2;
        
        return dummy->next;
    }
};
```

### 关键技巧

1. **虚拟头节点（Dummy Node）**：
   - 避免处理空链表的特殊情况
   - 统一处理第一个节点的连接

2. **双指针技巧**：
   - 同时遍历两个链表
   - 比较当前节点值，选择较小的

3. **直接连接节点**：
   - 不需要创建新节点，直接重新连接现有节点
   - 空间复杂度 O(1)

4. **处理剩余节点**：
   - 当一个链表遍历完时，直接将另一个链表的剩余部分连接上
   - 因为剩余部分已经有序，不需要再处理

---

## 复杂度分析

### 时间复杂度

- **O(m + n)**：其中 m 和 n 分别是两个链表的长度
- 需要遍历两个链表的所有节点，每个节点只访问一次

### 空间复杂度

- **O(1)**：只使用了常数额外空间（dummy、current 等）
- 不需要创建新节点，只是重新连接现有节点

---

## 常见错误

### 1. 忘记处理空链表

**错误代码：**
```c
while (list1 != NULL && list2 != NULL) {
    // ...
}
// 如果 list1 或 list2 为空，函数返回 NULL，但应该返回另一个链表
```

**问题**：如果其中一个链表为空，应该返回另一个链表。

**正确做法**：在循环后处理剩余节点，或者使用虚拟头节点统一处理。

### 2. 创建新节点（不符合题目要求）

**错误代码：**
```c
struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
newNode->val = list1->val;
current->next = newNode;
```

**问题**：题目要求通过拼接节点组成，不需要创建新节点。

**正确做法**：直接连接现有节点：
```c
current->next = list1;
```

### 3. 比较条件错误

**错误代码：**
```c
if (list1->val < list2->val) {  // 缺少等号
    // ...
}
```

**问题**：当两个节点值相等时，应该选择其中一个（通常选择 list1），但缺少等号会导致逻辑错误。

**正确做法**：使用 `<=` 或 `>=`，根据题目要求选择。

### 4. 忘记移动 current 指针

**错误代码：**
```c
current->next = list1;
list1 = list1->next;
// 忘记 current = current->next;
```

**问题**：`current` 指针没有移动，导致后续节点覆盖前面的连接。

**正确做法**：每次连接节点后，都要移动 `current` 指针。

### 5. 处理剩余节点时使用循环

**错误代码：**
```c
while (list1 != NULL) {
    current->next = list1;
    list1 = list1->next;
    current = current->next;
}
```

**问题**：虽然逻辑正确，但效率较低。

**正确做法**：直接连接整个剩余部分：
```c
current->next = list1;  // 直接连接整个剩余链表
```

---

## 扩展思考

### 1. 递归解法

虽然迭代更直观，但也可以使用递归：

```c
struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {
    //  base case
    if (list1 == NULL) return list2;
    if (list2 == NULL) return list1;
    
    // 选择较小的节点作为头节点
    if (list1->val <= list2->val) {
        list1->next = mergeTwoLists(list1->next, list2);
        return list1;
    } else {
        list2->next = mergeTwoLists(list1, list2->next);
        return list2;
    }
}
```

**优缺点**：
- 优点：代码简洁
- 缺点：空间复杂度 O(m + n)（递归调用栈）

### 2. 如果要求创建新节点怎么办？

如果题目要求创建新节点（而不是重新连接），可以这样实现：

```c
struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {
    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));
    struct ListNode* current = dummy;
    
    while (list1 != NULL && list2 != NULL) {
        struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
        if (list1->val <= list2->val) {
            newNode->val = list1->val;
            list1 = list1->next;
        } else {
            newNode->val = list2->val;
            list2 = list2->next;
        }
        newNode->next = NULL;
        current->next = newNode;
        current = current->next;
    }
    
    // 处理剩余节点（需要逐个创建）
    // ...
    
    return dummy->next;
}
```

### 3. 合并 K 个有序链表（LeetCode 23）

- 可以使用分治法：两两合并
- 可以使用优先队列（堆）：每次选择 K 个链表头节点中的最小值

### 4. 如何优化代码？

- 使用三元运算符简化剩余节点的处理：
```c
current->next = (list1 != NULL) ? list1 : list2;
```

- 使用更简洁的循环条件（但可读性可能降低）

---

**总结**：本题是链表操作的经典题目，核心是双指针技巧和虚拟头节点的使用。注意直接连接节点而不是创建新节点，这样可以达到 O(1) 空间复杂度。

