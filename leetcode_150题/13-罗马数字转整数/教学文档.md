# LeetCode 13. 罗马数字转整数 - 详细教学文档

## 📚 目录

1. [问题分析](#问题分析)
2. [错误直觉 vs 正确思路](#错误直觉-vs-正确思路)
3. [核心算法详解](#核心算法详解)
4. [伪代码或关键语句](#伪代码或关键语句)
5. [C/C++ 关键代码片段](#cc-关键代码片段)
6. [复杂度](#复杂度)
7. [常见错误](#常见错误)
8. [扩展思考](#扩展思考)

---

## 问题分析

### 题目要求

- 给定一个罗马数字字符串 `s`
- 将其转换为对应的整数值
- 需要正确处理 6 种特殊情况：IV(4)、IX(9)、XL(40)、XC(90)、CD(400)、CM(900)

### 关键约束

1. **字符串长度**：1 <= s.length <= 15
2. **字符范围**：仅包含 `I, V, X, L, C, D, M`
3. **数值范围**：结果在 [1, 3999] 内
4. **有效性保证**：输入保证是有效的罗马数字

### 核心难点

- **特殊情况识别**：如何判断当前字符应该与下一个字符组合（相减）还是单独处理（相加）
- **规则理解**：只有当前字符小于下一个字符时，才需要相减

---

## 错误直觉 vs 正确思路

### 错误直觉 ❌

1. **先全部转换为数字数组，再用双指针处理**  
   - 问题：增加了不必要的空间开销，且逻辑复杂
   - 示例：将 "IV" 转为 [1, 5]，然后判断 1 < 5，计算 5-1=4
   - 缺点：需要额外数组，代码冗长

2. **使用 if-else 枚举所有特殊情况**  
   - 问题：代码冗长，容易遗漏
   - 示例：if (s[i]=='I' && s[i+1]=='V') return 4; ...
   - 缺点：需要写 6 个特殊情况判断，代码重复

3. **从右到左扫描**  
   - 问题：虽然可行，但不符合从左到右的阅读习惯，理解成本高

### 正确思路 ✅

**核心思想：从左到右扫描，比较当前字符与下一个字符的值**

- 如果当前字符的值 < 下一个字符的值：说明是特殊情况（如 IV），需要相减
- 否则：正常情况，直接加上当前字符的值

**为什么这样可行？**

- 罗马数字的规则：小的数字在大的数字右边时相加，在左边时相减
- 从左到右扫描时，如果发现 `s[i] < s[i+1]`，说明 `s[i]` 是"减数"，应该计算 `s[i+1] - s[i]`
- 其他情况都是正常相加

---

## 核心算法详解

### 算法步骤

1. **建立字符到数值的映射**
   - 使用数组或哈希表存储每个字符对应的数值
   - C 语言可以用 switch-case 或数组索引
   - C++ 可以用 `unordered_map` 或数组

2. **从左到右遍历字符串**
   - 初始化 `result = 0`，`i = 0`
   - 对于每个位置 `i`：
     - 检查 `i+1` 是否越界
     - 如果 `i+1 < len` 且 `map[s[i]] < map[s[i+1]]`：
       - 这是特殊情况，计算 `map[s[i+1]] - map[s[i]]` 并加到结果
       - `i += 2`（跳过两个字符）
     - 否则：
       - 正常情况，加上 `map[s[i]]`
       - `i += 1`

3. **返回结果**

### 示例演示

以 `"MCMXCIV"` 为例：

| 步骤 | i | 当前字符 | 下一个字符 | 判断 | 操作 | result |
|------|---|---------|-----------|------|------|--------|
| 1    | 0 | M(1000) | C(100)    | 1000 > 100 | +1000 | 1000   |
| 2    | 1 | C(100)  | M(1000)   | 100 < 1000 | +900  | 1900   |
| 3    | 3 | X(10)   | C(100)    | 10 < 100   | +90   | 1990   |
| 4    | 5 | I(1)    | V(5)      | 1 < 5      | +4    | 1994   |

最终结果：1994

---

## 伪代码或关键语句

```
函数 romanToInt(s):
    // 建立字符到数值的映射
    map = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}
    
    result = 0
    i = 0
    
    while i < s.length:
        // 检查是否有下一个字符，且当前字符小于下一个字符
        if i + 1 < s.length AND map[s[i]] < map[s[i+1]]:
            result += map[s[i+1]] - map[s[i]]  // 特殊情况：相减
            i += 2  // 跳过两个字符
        else:
            result += map[s[i]]  // 正常情况：相加
            i += 1  // 移动到下一个字符
    
    return result
```

---

## C/C++ 关键代码片段

### C 语言实现

```c
// 辅助函数：获取字符对应的数值
int getValue(char c) {
    switch(c) {
        case 'I': return 1;
        case 'V': return 5;
        case 'X': return 10;
        case 'L': return 50;
        case 'C': return 100;
        case 'D': return 500;
        case 'M': return 1000;
        default: return 0;
    }
}

int romanToInt(char* s) {
    int result = 0;
    int len = strlen(s);
    
    for (int i = 0; i < len; i++) {
        int current = getValue(s[i]);
        
        // 检查是否有下一个字符，且当前字符小于下一个字符
        if (i + 1 < len && current < getValue(s[i + 1])) {
            // 特殊情况：相减
            result += getValue(s[i + 1]) - current;
            i++;  // 跳过下一个字符（因为已经在本次处理了）
        } else {
            // 正常情况：相加
            result += current;
        }
    }
    
    return result;
}
```

### C++ 实现

```cpp
class Solution {
public:
    int romanToInt(string s) {
        unordered_map<char, int> map = {
            {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50},
            {'C', 100}, {'D', 500}, {'M', 1000}
        };
        
        int result = 0;
        int n = s.length();
        
        for (int i = 0; i < n; i++) {
            int current = map[s[i]];
            
            // 检查是否有下一个字符，且当前字符小于下一个字符
            if (i + 1 < n && current < map[s[i + 1]]) {
                // 特殊情况：相减
                result += map[s[i + 1]] - current;
                i++;  // 跳过下一个字符
            } else {
                // 正常情况：相加
                result += current;
            }
        }
        
        return result;
    }
};
```

---

## 复杂度

- **时间复杂度：** O(n)  
  其中 n 是字符串的长度。每个字符最多被访问一次，且每次访问的操作都是 O(1)。

- **空间复杂度：** O(1)  
  只使用了常数额外空间（映射表的大小是固定的 7 个字符，不随输入增长）。

---

## 常见错误

1. **数组越界**  
   在访问 `s[i+1]` 之前没有检查 `i+1 < len`，导致越界访问。

2. **特殊情况判断错误**  
   只判断了 `s[i] < s[i+1]`，但没有考虑边界情况（如最后一个字符）。

3. **索引更新错误**  
   处理特殊情况后，忘记 `i++` 跳过下一个字符，导致重复处理。

4. **字符映射错误**  
   在 C 语言中使用 `sizeof(s)/sizeof(s[0])` 计算字符串长度（这是错误的，应该用 `strlen(s)`）。

5. **理解偏差**  
   误以为需要先全部转换再处理，增加了不必要的复杂度。

---

## 扩展思考

1. **逆问题：整数转罗马数字（LeetCode 12）**  
   - 如何将整数转换为罗马数字？
   - 需要从大到小贪心地选择最大的符号

2. **验证罗马数字的有效性**  
   - 如何判断一个字符串是否是有效的罗马数字？
   - 需要考虑更多规则，如不能有超过 3 个连续的相同字符

3. **其他进制转换**  
   - 二进制、八进制、十六进制转换
   - 与罗马数字转换的异同

4. **优化空间**  
   - 如果字符串很长，是否有优化方法？
   - 实际上本题字符串长度最多 15，优化意义不大

---

**总结：** 本题是字符串处理的经典题目，核心在于理解罗马数字的规则，特别是"小数字在大数字左边时相减"这一特殊情况。掌握从左到右扫描、比较相邻字符的思路后，类似的字符串转换问题都可以触类旁通。👍

