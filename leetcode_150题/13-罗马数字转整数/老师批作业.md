## 初次提交代码

```c
int romanToInt(char* s) {
    /*
    思路：用数组全部收集起来
    然后用快慢指针，如果快指针的值小于等于慢指针的值，那就直接把慢指针的值加到sum里面去，fast++，slow++
    如果快指针的值大于慢指针的值，那就把nums[fast]-nums[slow]的值加到sum里面去，fast+2，slow+2
    */
    int numsSize=sizeof(s)/sizeof(s[0]);
    int *nums=(int *)malloc(sizeof(int)*numsSize);
    int sum=0;
    for(int i=0;i<numsSize;i++){
        if(s[i]=='I'){
            nums[i]=1;
        }else if(s[i]=='V'){
            nums[i]=5;
        }else if(s[i]=='X'){
            nums[i]=10;
        }else if(s[i]=='L'){
            nums[i]=50;
        }else if(s[i]=='C'){
            nums[i]=100;
        }else if(s[i]=='D'){
            nums[i]=500;
        }else if(s[i]=='M'){
            nums[i]=1000;
        }
    }
    int slow=0;
    int fast=1;
    for(;fast<numsSize;){
        if(nums[fast]<=nums[slow]){
            sum+=nums[slow];
            fast++;
            slow++;
        }else{
            sum=sum+nums[fast]-nums[slow];
            fast=fast+2;
            slow=slow+2;
        }
    }
    if(nums[fast]<=nums[slow]){
        sum+=nums[slow]+nums[fast];
    }else{
        sum=sum+nums[fast]-nums[slow];
    }
    return sum;

    free (nums);
}
```

## 批阅意见

### 1. 语法错误：字符串长度计算错误 ❌

**问题：** `int numsSize=sizeof(s)/sizeof(s[0]);` 这行代码是错误的。

**原因：** 
- `s` 是一个 `char*` 类型的指针参数，不是数组
- `sizeof(s)` 只会返回指针的大小（在 32 位系统上是 4 字节，64 位系统上是 8 字节），而不是字符串的长度
- `sizeof(s[0])` 是 `char` 的大小（1 字节）
- 因此 `numsSize` 会被错误地计算为 4 或 8，而不是实际的字符串长度

**正确做法：** 使用 `strlen(s)` 来获取字符串长度
```c
int numsSize = strlen(s);
```

### 2. 逻辑错误：快慢指针的初始化和移动逻辑有问题 ❌

**问题：** 
- `slow=0, fast=1` 的初始化导致第一个字符 `nums[0]` 可能被遗漏
- 循环条件 `for(;fast<numsSize;)` 中，当 `fast` 和 `slow` 都增加 2 时，可能导致越界
- 循环结束后还有额外的判断，但此时 `fast` 可能已经越界

**分析：**
- 对于输入 `"III"`，如果 `numsSize` 被错误计算为 4，循环可能不会正确处理
- 对于输入 `"IV"`，`slow=0, fast=1`，`nums[1]=5 > nums[0]=1`，会执行 `sum += 5-1=4`，然后 `fast=3, slow=2`，但此时 `fast=3` 已经越界（实际长度是 2）

**正确思路：** 
- 应该从左到右扫描，比较当前字符和下一个字符
- 如果当前字符的值 < 下一个字符的值，则相减；否则相加
- 不需要使用快慢指针，只需要一个索引 `i` 即可

### 3. 内存泄漏：free 在 return 之后 ❌

**问题：** `free(nums);` 在 `return sum;` 之后，永远不会执行。

**正确做法：** 在 `return` 之前调用 `free(nums);`

### 4. 思路偏差：不必要的数组分配 ❌

**问题：** 先分配数组存储所有字符的数值，然后再处理，增加了空间复杂度。

**建议：** 可以直接在遍历字符串时处理，不需要额外的数组，空间复杂度可以从 O(n) 优化到 O(1)。

### 5. 边界情况处理不当 ❌

**问题：** 
- 循环结束后的额外判断 `if(nums[fast]<=nums[slow])` 中，`fast` 可能已经越界
- 没有处理字符串长度为 1 的情况

### 6. 代码风格问题 ⚠️

- 变量命名可以更清晰（如 `result` 比 `sum` 更符合题意）
- 缺少必要的头文件 `#include <string.h>`（使用 `strlen` 需要）

## 改进建议

### 核心思路修正

正确的算法应该是：
1. 从左到右遍历字符串
2. 对于每个位置 `i`，检查 `i+1` 是否越界
3. 如果 `s[i]` 的值 < `s[i+1]` 的值，则计算 `s[i+1] - s[i]` 并加到结果，然后 `i += 2`
4. 否则，直接加上 `s[i]` 的值，然后 `i += 1`

### 参考正确实现

```c
#include <string.h>

int getValue(char c) {
    switch(c) {
        case 'I': return 1;
        case 'V': return 5;
        case 'X': return 10;
        case 'L': return 50;
        case 'C': return 100;
        case 'D': return 500;
        case 'M': return 1000;
        default: return 0;
    }
}

int romanToInt(char* s) {
    int result = 0;
    int len = strlen(s);
    
    for (int i = 0; i < len; i++) {
        int current = getValue(s[i]);
        if (i + 1 < len && current < getValue(s[i + 1])) {
            result += getValue(s[i + 1]) - current;
            i++;
        } else {
            result += current;
        }
    }
    
    return result;
}
```

## 总结

初次提交的代码在思路上有一定想法（使用数组存储、快慢指针），但存在以下主要问题：
1. **语法错误**：`sizeof` 计算字符串长度的方法完全错误
2. **逻辑错误**：快慢指针的移动逻辑不符合罗马数字的转换规则
3. **内存管理**：`free` 位置错误，且不必要的内存分配
4. **边界处理**：循环结束后的判断可能导致越界访问

建议重新理解题目要求，采用"从左到右扫描，比较相邻字符"的简单思路，避免过度设计。

