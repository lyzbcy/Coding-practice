# LeetCode 380. O(1) 时间插入、删除和获取随机元素 - 详细教学文档

## 📚 目录

1. [问题分析](#问题分析)
2. [思路解析](#思路解析)
3. [算法详解](#算法详解)
4. [代码实现](#代码实现)
5. [复杂度分析](#复杂度分析)
6. [常见错误](#常见错误)
7. [扩展思考](#扩展思考)

---

## 问题分析

### 题目要求

- 实现一个数据结构，支持三种操作：
  - `insert(val)`: 插入元素，平均时间复杂度 O(1)
  - `remove(val)`: 删除元素，平均时间复杂度 O(1)
  - `getRandom()`: 随机返回一个元素，平均时间复杂度 O(1)，每个元素概率相等

### 关键约束

1. **所有操作的平均时间复杂度必须是 O(1)**
2. **随机获取时，每个元素被选中的概率必须相等**
3. 最多调用 `2 * 10⁵` 次操作，需要高效实现

---

## 思路解析

### 错误直觉 ❌

1. **只使用数组**
   - 插入：O(1) ✅
   - 删除：需要查找元素位置 O(n)，然后移动元素 O(n) ❌
   - 随机获取：O(1) ✅

2. **只使用哈希表（如 unordered_set）**
   - 插入：O(1) ✅
   - 删除：O(1) ✅
   - 随机获取：无法直接随机访问，需要转换为数组 O(n) ❌

3. **使用有序数组 + 二分查找**
   - 插入：需要维护有序性 O(n) ❌
   - 删除：需要移动元素 O(n) ❌
   - 随机获取：O(1) ✅

### 正确思路 ✅

**核心思想：组合使用哈希表和数组**

- **数组 `nums`**：存储所有元素，支持 O(1) 随机访问
- **哈希表 `valToIndex`**：存储元素值到数组索引的映射，支持 O(1) 查找和删除

**关键技巧：删除时交换到末尾**

删除元素时，不是直接删除（会导致移动），而是：
1. 找到要删除的元素在数组中的位置
2. 将该位置与数组最后一个元素交换
3. 删除最后一个元素（O(1)）
4. 更新哈希表中的映射关系

---

## 算法详解

### 数据结构设计

```cpp
class RandomizedSet {
private:
    vector<int> nums;                    // 存储所有元素
    unordered_map<int, int> valToIndex;  // 值 -> 数组索引的映射
};
```

### 操作详解

#### 1. insert(val)

```
1. 检查 val 是否已存在（通过哈希表）
   - 如果存在：返回 false
   - 如果不存在：
     a. 将 val 添加到数组末尾
     b. 在哈希表中记录 val -> 数组末尾索引
     c. 返回 true
```

**时间复杂度：** O(1) 平均情况

#### 2. remove(val)

```
1. 检查 val 是否存在（通过哈希表）
   - 如果不存在：返回 false
   - 如果存在：
     a. 获取 val 在数组中的索引 idx
     b. 获取数组最后一个元素 lastVal
     c. 将数组末尾元素移动到 idx 位置（覆盖要删除的元素）
     d. 更新哈希表：lastVal -> idx
     e. 删除哈希表中 val 的映射
     f. 删除数组最后一个元素（size--）
     g. 返回 true
```

**关键点：** 交换后，原来在末尾的元素现在在 idx 位置，需要更新哈希表映射。

**时间复杂度：** O(1) 平均情况

#### 3. getRandom()

```
1. 生成一个 [0, nums.size()) 范围内的随机索引
2. 返回 nums[随机索引]
```

**时间复杂度：** O(1)

**为什么每个元素概率相等？**  
因为数组是连续存储的，每个位置被选中的概率都是 1/n。

---

## 代码实现

### C 语言实现

```c
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

#define MAX_SIZE 200000

typedef struct {
    int* nums;              // 数组存储元素
    int size;               // 当前元素个数
    int capacity;           // 数组容量
    int* valToIndex;        // 值到索引的映射（使用数组模拟哈希表）
    int mapSize;            // 映射表大小
} RandomizedSet;

RandomizedSet* randomizedSetCreate() {
    RandomizedSet* obj = (RandomizedSet*)malloc(sizeof(RandomizedSet));
    obj->capacity = 16;
    obj->size = 0;
    obj->nums = (int*)malloc(sizeof(int) * obj->capacity);
    obj->mapSize = 200001;  // 值范围：-2^31 到 2^31-1，需要偏移处理
    obj->valToIndex = (int*)malloc(sizeof(int) * obj->mapSize);
    // 初始化为 -1 表示不存在
    memset(obj->valToIndex, -1, sizeof(int) * obj->mapSize);
    return obj;
}

bool randomizedSetInsert(RandomizedSet* obj, int val) {
    // 将 val 映射到非负索引（偏移 100000）
    int key = val + 100000;
    if (key < 0 || key >= obj->mapSize) return false;
    
    // 检查是否已存在
    if (obj->valToIndex[key] != -1) {
        return false;
    }
    
    // 扩容检查
    if (obj->size >= obj->capacity) {
        obj->capacity *= 2;
        obj->nums = (int*)realloc(obj->nums, sizeof(int) * obj->capacity);
    }
    
    // 添加到数组末尾
    obj->nums[obj->size] = val;
    obj->valToIndex[key] = obj->size;
    obj->size++;
    return true;
}

bool randomizedSetRemove(RandomizedSet* obj, int val) {
    int key = val + 100000;
    if (key < 0 || key >= obj->mapSize) return false;
    
    // 检查是否存在
    int idx = obj->valToIndex[key];
    if (idx == -1) {
        return false;
    }
    
    // 将最后一个元素移动到 idx 位置
    int lastVal = obj->nums[obj->size - 1];
    obj->nums[idx] = lastVal;
    
    // 更新最后一个元素的索引映射
    int lastKey = lastVal + 100000;
    obj->valToIndex[lastKey] = idx;
    
    // 删除 val 的映射
    obj->valToIndex[key] = -1;
    
    // 删除数组最后一个元素
    obj->size--;
    return true;
}

int randomizedSetGetRandom(RandomizedSet* obj) {
    int randomIndex = rand() % obj->size;
    return obj->nums[randomIndex];
}

void randomizedSetFree(RandomizedSet* obj) {
    if (obj) {
        free(obj->nums);
        free(obj->valToIndex);
        free(obj);
    }
}
```

**注意：** C 语言版本使用数组模拟哈希表，需要处理负数偏移。实际面试中更推荐使用 C++ 的 `unordered_map`。

### C++ 实现（推荐）

```cpp
#include <vector>
#include <unordered_map>
#include <cstdlib>

class RandomizedSet {
private:
    std::vector<int> nums;                    // 存储所有元素
    std::unordered_map<int, int> valToIndex; // 值 -> 数组索引的映射

public:
    RandomizedSet() {
        // 构造函数，初始化随机数种子（可选）
        srand(time(nullptr));
    }
    
    bool insert(int val) {
        // 如果已存在，返回 false
        if (valToIndex.find(val) != valToIndex.end()) {
            return false;
        }
        
        // 添加到数组末尾
        nums.push_back(val);
        // 记录索引
        valToIndex[val] = nums.size() - 1;
        return true;
    }
    
    bool remove(int val) {
        // 如果不存在，返回 false
        if (valToIndex.find(val) == valToIndex.end()) {
            return false;
        }
        
        // 获取要删除元素的索引
        int idx = valToIndex[val];
        // 获取最后一个元素
        int lastVal = nums.back();
        
        // 将最后一个元素移动到 idx 位置
        nums[idx] = lastVal;
        // 更新最后一个元素的索引映射
        valToIndex[lastVal] = idx;
        
        // 删除数组最后一个元素
        nums.pop_back();
        // 删除哈希表中的映射
        valToIndex.erase(val);
        
        return true;
    }
    
    int getRandom() {
        // 生成随机索引
        int randomIndex = rand() % nums.size();
        return nums[randomIndex];
    }
};
```

---

## 复杂度分析

### 时间复杂度

- **insert(val)**: O(1) 平均情况
  - 哈希表查找：O(1)
  - 数组末尾插入：O(1)
  - 哈希表插入：O(1)

- **remove(val)**: O(1) 平均情况
  - 哈希表查找：O(1)
  - 数组交换：O(1)
  - 哈希表更新和删除：O(1)

- **getRandom()**: O(1)
  - 随机数生成：O(1)
  - 数组访问：O(1)

### 空间复杂度

- **O(n)**：n 为元素个数
  - 数组存储：O(n)
  - 哈希表存储：O(n)

---

## 常见错误

1. **删除时忘记更新哈希表**  
   交换元素后，必须更新被移动元素的索引映射，否则后续操作会出错。

2. **删除时直接删除导致移动**  
   如果直接删除中间元素，需要移动后续元素，时间复杂度变为 O(n)。

3. **随机获取时使用哈希表迭代**  
   哈希表的迭代顺序不确定，且无法直接随机访问，必须使用数组。

4. **边界情况处理不当**  
   - 删除最后一个元素时的特殊处理
   - 空集合时的随机获取（题目保证至少有一个元素）

5. **C 语言版本中哈希表实现错误**  
   使用数组模拟哈希表时，需要正确处理负数偏移和冲突。

---

## 扩展思考

1. **381. O(1) 时间插入、删除和获取随机元素 - 允许重复**  
   需要支持重复元素，可以使用 `unordered_map<int, unordered_set<int>>` 存储每个值对应的所有索引。

2. **为什么删除时交换到末尾？**  
   因为数组末尾的删除是 O(1)，而中间删除需要移动元素是 O(n)。

3. **能否使用其他数据结构？**  
   - 平衡二叉搜索树：插入删除 O(log n)，随机获取需要额外处理
   - 跳表：可以实现，但实现复杂度高

4. **实际应用场景**  
   - 抽奖系统：需要随机选择用户
   - 游戏中的随机道具生成
   - 负载均衡中的随机服务器选择

---

**总结：** 本题是经典的数据结构设计题，核心在于理解不同数据结构的优缺点，通过组合使用来同时满足多个 O(1) 操作的要求。掌握本题后，可以触类旁通解决其他类似的设计题。👍

