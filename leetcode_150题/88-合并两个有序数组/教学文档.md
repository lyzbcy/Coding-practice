# LeetCode 88. 合并两个有序数组 - 详细教学文档

## 📚 目录

1. [问题分析](#问题分析)
2. [思路解析](#思路解析)
3. [算法详解](#算法详解)
4. [代码实现](#代码实现)
5. [复杂度分析](#复杂度分析)
6. [常见错误](#常见错误)
7. [扩展思考](#扩展思考)

---

## 问题分析

### 题目要求

- 将两个**非递减顺序**排列的数组 `nums1` 和 `nums2` 合并
- 合并后的结果存储在 `nums1` 中
- `nums1` 的初始长度为 `m + n`，前 `m` 个元素是有效数据，后 `n` 个位置为 0（预留空间）
- `nums2` 的长度为 `n`

### 关键约束

1. **不能使用额外空间**：结果必须直接存储在 `nums1` 中
2. **不能覆盖未处理的元素**：如果从前往后合并，会覆盖 `nums1` 中还未处理的元素
3. **时间复杂度要求**：进阶要求 O(m + n)

---

## 思路解析

### 错误思路 ❌

**从前往后合并：**
```
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6], n = 3

如果从前往后：
- 比较 nums1[0]=1 和 nums2[0]=2，1 < 2，把 1 放到位置 0 ✓
- 比较 nums1[1]=2 和 nums2[0]=2，2 = 2，把 2 放到位置 1 ✓
- 比较 nums1[2]=3 和 nums2[0]=2，3 > 2，把 2 放到位置 2...
  但是位置 2 原本是 3！我们覆盖了还没处理的元素 ❌
```

### 正确思路 ✅

**从后往前合并：**

利用 `nums1` 后 `n` 个位置是空的这个特点，从后往前填充，这样：
- 不会覆盖 `nums1` 中还未处理的元素
- 不需要额外的空间
- 时间复杂度为 O(m + n)

---

## 算法详解

### 核心思想

使用**三指针**技术：
- `i`：指向 `nums1` 有效元素的最后一个位置（从 `m-1` 开始）
- `j`：指向 `nums2` 的最后一个位置（从 `n-1` 开始）
- `k`：指向 `nums1` 的最后一个位置，用于存放合并后的元素（从 `m+n-1` 开始）

### 算法步骤

1. **初始化三个指针**
   ```
   i = m - 1    // nums1 最后一个有效元素
   j = n - 1    // nums2 最后一个元素
   k = m + n - 1 // 合并后数组的最后一个位置
   ```

2. **从后往前比较并填充**
   - 比较 `nums1[i]` 和 `nums2[j]`
   - 将较大的元素放到 `nums1[k]`
   - 相应的指针向前移动

3. **处理剩余元素**
   - 如果 `nums2` 还有剩余元素，直接复制到 `nums1`
   - 如果 `nums1` 还有剩余元素，它们已经在正确位置，无需移动

### 示例演示

**示例 1：**
```
初始状态：
nums1 = [1, 2, 3, 0, 0, 0], m = 3
nums2 = [2, 5, 6], n = 3

i = 2, j = 2, k = 5

步骤 1：比较 nums1[2]=3 和 nums2[2]=6
        3 < 6，所以 nums1[5] = 6
        nums1 = [1, 2, 3, 0, 0, 6]
        j = 1, k = 4

步骤 2：比较 nums1[2]=3 和 nums2[1]=5
        3 < 5，所以 nums1[4] = 5
        nums1 = [1, 2, 3, 0, 5, 6]
        j = 0, k = 3

步骤 3：比较 nums1[2]=3 和 nums2[0]=2
        3 > 2，所以 nums1[3] = 3
        nums1 = [1, 2, 3, 3, 5, 6]
        i = 1, k = 2

步骤 4：比较 nums1[1]=2 和 nums2[0]=2
        2 = 2，所以 nums1[2] = 2
        nums1 = [1, 2, 2, 3, 5, 6]
        j = -1, k = 1

步骤 5：j < 0，nums2 处理完毕
        nums1 剩余元素 [1, 2] 已经在正确位置

最终结果：nums1 = [1, 2, 2, 3, 5, 6] ✓
```

---

## 代码实现

### C 语言版本

```c
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n) {
    int i = m - 1;      // nums1 有效元素的最后一个位置
    int j = n - 1;      // nums2 的最后一个位置
    int k = m + n - 1;  // nums1 的最后一个位置（合并后的位置）
    
    // 从后往前比较并填充
    while (i >= 0 && j >= 0) {
        if (nums1[i] > nums2[j]) {
            nums1[k--] = nums1[i--];
        } else {
            nums1[k--] = nums2[j--];
        }
    }
    
    // 如果 nums2 还有剩余元素，直接复制到 nums1
    while (j >= 0) {
        nums1[k--] = nums2[j--];
    }
    
    // 如果 nums1 还有剩余元素，它们已经在正确的位置，不需要移动
}
```

### 代码解释

1. **指针初始化**
   ```c
   int i = m - 1;      // 指向 nums1 最后一个有效元素
   int j = n - 1;      // 指向 nums2 最后一个元素
   int k = m + n - 1;  // 指向合并后数组的最后一个位置
   ```

2. **主循环**
   ```c
   while (i >= 0 && j >= 0) {
       if (nums1[i] > nums2[j]) {
           nums1[k--] = nums1[i--];  // nums1[i] 更大，放到 k 位置
       } else {
           nums1[k--] = nums2[j--];  // nums2[j] 更大或相等，放到 k 位置
       }
   }
   ```
   - 当两个数组都还有元素时，比较并填充
   - 使用后缀递减运算符 `--` 简化代码

3. **处理剩余元素**
   ```c
   while (j >= 0) {
       nums1[k--] = nums2[j--];
   }
   ```
   - 如果 `nums2` 还有剩余，直接复制
   - 如果 `nums1` 还有剩余，已经在正确位置，无需处理

---

## 复杂度分析

### 时间复杂度：O(m + n)

- 最坏情况：需要遍历 `nums1` 的 `m` 个元素和 `nums2` 的 `n` 个元素
- 每个元素最多被访问一次
- 因此时间复杂度为 O(m + n)

### 空间复杂度：O(1)

- 只使用了几个额外的变量（`i`, `j`, `k`）
- 没有使用额外的数组或递归栈
- 因此空间复杂度为 O(1)

---

## 常见错误

### 错误 1：从前往后合并

```c
// ❌ 错误代码
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n) {
    int i = 0, j = 0, k = 0;
    while (i < m && j < n) {
        if (nums1[i] < nums2[j]) {
            nums1[k++] = nums1[i++];  // 会覆盖未处理的元素！
        } else {
            nums1[k++] = nums2[j++];
        }
    }
    // ...
}
```

**问题：** 当 `k > i` 时，会覆盖 `nums1` 中还未处理的元素。

### 错误 2：忘记处理剩余元素

```c
// ❌ 错误代码
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n) {
    int i = m - 1, j = n - 1, k = m + n - 1;
    while (i >= 0 && j >= 0) {
        // ... 合并逻辑
    }
    // 忘记处理 nums2 的剩余元素！
}
```

**问题：** 如果 `nums2` 还有剩余元素，结果不完整。

### 错误 3：边界条件处理不当

```c
// ❌ 错误代码
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n) {
    if (n == 0) return;  // 可以，但不是必须的
    if (m == 0) {
        // 需要将 nums2 全部复制到 nums1
        for (int i = 0; i < n; i++) {
            nums1[i] = nums2[i];
        }
        return;
    }
    // ...
}
```

**说明：** 虽然这样处理边界条件也可以，但我们的算法已经能正确处理这些情况，无需额外判断。

---

## 扩展思考

### 1. 如果要求返回新数组怎么办？

如果题目要求返回一个新数组而不是修改 `nums1`，可以这样做：

```c
int* merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n) {
    int* result = (int*)malloc((m + n) * sizeof(int));
    int i = 0, j = 0, k = 0;
    
    while (i < m && j < n) {
        if (nums1[i] < nums2[j]) {
            result[k++] = nums1[i++];
        } else {
            result[k++] = nums2[j++];
        }
    }
    
    while (i < m) result[k++] = nums1[i++];
    while (j < n) result[k++] = nums2[j++];
    
    return result;
}
```

### 2. 如果数组是降序排列怎么办？

只需要修改比较条件：

```c
if (nums1[i] < nums2[j]) {  // 改为 <
    nums1[k--] = nums1[i--];
} else {
    nums1[k--] = nums2[j--];
}
```

### 3. 如何合并多个有序数组？

可以使用**归并排序**的思想，或者使用**优先队列（堆）**：

```c
// 使用优先队列合并 k 个有序数组
// 时间复杂度：O(n * log k)，其中 n 是总元素数
```

### 4. 实际应用场景

- **数据库合并**：合并两个有序的查询结果
- **日志合并**：合并多个时间有序的日志文件
- **归并排序**：这是归并排序中"合并"步骤的核心算法

---

## 总结

### 核心要点

1. ✅ **从后往前合并**：利用 `nums1` 后 `n` 个位置为空的特点
2. ✅ **三指针技术**：`i`、`j`、`k` 分别指向三个关键位置
3. ✅ **处理剩余元素**：确保 `nums2` 的所有元素都被处理
4. ✅ **时间复杂度 O(m+n)**：每个元素只访问一次
5. ✅ **空间复杂度 O(1)**：只使用常数额外空间

### 解题模板

```c
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n) {
    int i = m - 1, j = n - 1, k = m + n - 1;
    
    while (i >= 0 && j >= 0) {
        nums1[k--] = (nums1[i] > nums2[j]) ? nums1[i--] : nums2[j--];
    }
    
    while (j >= 0) {
        nums1[k--] = nums2[j--];
    }
}
```

### 练习建议

1. 先理解为什么不能从前往后合并
2. 手动模拟几个例子，理解算法流程
3. 注意边界条件（空数组、单元素数组等）
4. 尝试用不同语言实现（C、C++、Java、Python）

---

**祝你刷题愉快！** 🎉

