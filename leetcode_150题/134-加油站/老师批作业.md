## 初次提交代码

```c
int canCompleteCircuit(int* gas, int gasSize, int* cost, int costSize) {



    /*

    思路：就遍历呗 两层遍历

    */

    if(gasSize!=costSize){

        return -1;

    }

    for(int i=0;i<gasSize;i++){ //遍历出发点

        int qiyou=0;

        for(int j=0;j<gasSize;j++){ //遍历能否跑完

            int current = i+j;

            int next = current+1;

            if(current>=gasSize){

                current-=gasSize;

            }

            if(next>=gasSize){

                next-=gasSize;

            }

            qiyou+=gas[current];

            if(qiyou<cost[next]){

                goto no;

            }else{

                qiyou-=cost[next];

            }

        }

        return i;

        no:;

    }

    return -1;

}
```

## 批阅意见

1. **时间复杂度 O(n²)**：外层遍历起点、内层暴力模拟整圈，`n=10^5` 时会直接超时，且题目已暗示要在线性时间内完成。
2. **油耗索引错误**：从 `current` 到下一站应消耗 `cost[current]`，但代码使用 `cost[next]`，相当于每段路都错用下一段的耗油量，逻辑不符题意。
3. **油量更新顺序不准确**：应该“先扣 cost，再加下站 gas”，代码却在进入下一站前先加油再扣油，导致模拟顺序与真实行驶顺序相反。
4. **`goto` 跳转破坏可读性**：通过 `goto no` 提前跳出不仅让逻辑难懂，还容易遗漏必要的变量重置，建议用 `break` + 标记变量或直接使用贪心一次遍历。
5. **缺失全局判定**：没有累加 `sum(gas) - sum(cost)` 来判断“总体油够不够”，即便暴力模拟也可能得到错误结论。

建议回到教学文档的贪心思路：单次遍历维护 `total` 与 `tank`，一旦 `tank < 0` 就把起点移到下一站，如此即可在 O(n) 内找到唯一解。


