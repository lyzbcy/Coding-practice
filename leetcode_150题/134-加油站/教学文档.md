# LeetCode 134. 加油站 - 教学文档

## 📚 目录

1. [问题分析](#问题分析)
2. [思路解析](#思路解析)
3. [算法详解](#算法详解)
4. [代码实现](#代码实现)
5. [复杂度分析](#复杂度分析)
6. [常见错误](#常见错误)
7. [扩展思考](#扩展思考)

---

## 问题分析

### 题目要求

- 给定两个长度相同的数组 `gas`、`cost`
- 可从任意加油站出发，初始油量为 0，油箱无限大
- 行驶顺序固定为顺时针走完整个环路
- 如果存在解，返回唯一的起点索引；否则返回 `-1`

### 关键约束

1. `n` 最多 `10^5` —— 需要 **O(n)** 解法
2. 油箱容量无限 —— 只需关心净变化 `gas[i] - cost[i]`
3. 唯一解保证 —— 找到任一可行起点即可返回

---

## 思路解析

### 错误直觉 ❌

1. **暴力从每个站点尝试**  
   需要嵌套循环，时间复杂度 O(n²)，`n=10^5` 时会超时。
2. **贪心地选择 `gas[i] - cost[i]` 最大的站点**  
   局部最大差值不一定能保证整体路程不为负。
3. **随意调整油箱容量或一次存储全部油量**  
   题目明确油箱无限，问题关键在“走完某区间后油量是否跌破 0”。

### 正确思路 ✅

1. **总油量判定**  
   若 `sum(gas) < sum(cost)`，无论起点如何都不可能完成一圈。
2. **线性扫描 + 贪心重置**  
   - 维护 `total`：全局油量差
   - 维护 `tank`：从当前起点出发的实时油量
   - 当 `tank < 0` 时，说明当前起点无法抵达下一站，直接把起点重置为下一站，油箱清零继续试。
3. **唯一解解释**  
   若存在解，则刚好在 `tank` 为负的地方“切断”区间，最后留下的 `start` 即唯一答案。

---

## 算法详解

1. **变量含义**
   - `total`：遍历所有站点的累计净油量，用于判断是否存在解
   - `tank`：当前假设起点能够积累到的油量，跌破 0 就说明起点无效
   - `start`：当前假设的起点索引

2. **遍历过程**
   ```
   total += gas[i] - cost[i]
   tank  += gas[i] - cost[i]
   如果 tank < 0：
       start = i + 1
       tank = 0
   ```

   - `tank < 0` 代表从 `start` 到 `i` 这段路亏油，`start` 不可能是答案
   - 清空油箱代表重新从新的起点累计

3. **结束判断**
   - 若 `total < 0` 返回 `-1`
   - 否则返回 `start`（对 `n` 取模即可）

4. **正确性的直觉**
   - `start` 之前的任意位置都在某次迭代中被判定为“油箱会负”，因此必定无解
   - `start` 之后再也没触发 `tank < 0`，说明从 `start` 出发整个环路油量始终非负

---

## 代码实现

### C 语言核心代码

```c
int canCompleteCircuit(int* gas, int gasSize, int* cost, int costSize) {
    if (gasSize <= 0 || gasSize != costSize) {
        return -1;
    }

    int total = 0;
    int tank = 0;
    int start = 0;

    for (int i = 0; i < gasSize; i++) {
        int gain = gas[i] - cost[i];
        total += gain;
        tank += gain;
        if (tank < 0) {
            start = i + 1;
            tank = 0;
        }
    }

    return total >= 0 ? start % gasSize : -1;
}
```

### C++ 版本

```cpp
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int n = gas.size();
        if (n == 0 || n != cost.size()) {
            return -1;
        }

        int total = 0;
        int tank = 0;
        int start = 0;

        for (int i = 0; i < n; i++) {
            int gain = gas[i] - cost[i];
            total += gain;
            tank += gain;
            if (tank < 0) {
                start = i + 1;
                tank = 0;
            }
        }

        return total >= 0 ? start % n : -1;
    }
};
```

---

## 复杂度分析

- **时间复杂度：** `O(n)`  
  只需要遍历每个加油站一次。

- **空间复杂度：** `O(1)`  
  仅使用常数级变量 `total`、`tank`、`start`。

---

## 常见错误

1. **遗漏总油量检查**  
   只靠 `tank` 不够，`total < 0` 时必须直接返回 `-1`。
2. **重置后未清空油箱**  
   起点更换后 `tank` 仍沿用旧值，会导致错误判断。
3. **把消耗写成 `cost[i+1]` 或越界**  
   从 `i` 到下一站的消耗应为 `cost[i]`。
4. **返回 `start` 之前忘记取模**  
   虽然 `start` 只会增长到 `n`，但写成 `% n` 更稳妥。
5. **误用 long long**  
   数据范围在 `int` 内即可，不必过度提升类型。

---

## 扩展思考

1. **如果允许绕环多圈？**  
   当前算法仍适用，因为 `total >= 0` 表示油量盈余，绕多圈也不会亏油。
2. **能否找出所有可行起点？**  
   本题保证唯一解；若不唯一，可在扫描末尾再补一次遍历确认其它位置。
3. **与“跳跃游戏”类题目对比**  
   两者都依赖维护“当前区间是否可持续”的贪心思想，可一同练习。
4. **如何可视化**  
   配合集成的 `动画演示.py`，观察 `total`、`tank`、`start` 的变化，更直观。

---

把握“总量够 + 局部不亏”这两重条件，就能轻松拿下本题。加油！🚗⛽️


