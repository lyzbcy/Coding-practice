# 134. 加油站

题目来源：https://leetcode.cn/problems/gas-station/

---

## 📝 题目描述

在一条 **首尾相接的环形公路** 上分布着 `n` 个加油站：  
第 `i` 个加油站能提供 `gas[i]` 升汽油，从该站行驶到下一站需要消耗 `cost[i]` 升汽油。  

你驾驶一辆油箱容量无限的汽车，可以从任意加油站出发，但出发时油箱为空。请判断是否存在一个起点，使得沿着环路顺序行驶一周后油量始终不为负并回到起点；若存在，则返回那个起点的索引，否则返回 `-1`。  

> 题目保证：如果答案存在，那么它是唯一的。

---

## ✅ 输出规范

- 如果能跑完一圈，输出 **起始加油站的索引**（0-based）。  
- 如果无法完成一圈，返回 `-1`。  
- 数组 `gas` 与 `cost` 的长度必定相等，表示加油站数量。

---

## 🔢 示例

### 示例 1

**输入：**  
`gas = [1,2,3,4,5]`  
`cost = [3,4,5,1,2]`

**输出：** `3`

**解释：**  
从索引 3 出发：油箱先加 `4`，前往 4 号站消耗 `1`，到达后再加 `5`，如此循环一周油量始终不为负，最后回到起点。

---

### 示例 2

**输入：**  
`gas = [2,3,4]`  
`cost = [3,4,3]`

**输出：** `-1`

**解释：**  
任意起点都会在途中油量变成负数，无法回到出发站。

---

## 📌 提示 / 约束

- `n == gas.length == cost.length`
- `1 <= n <= 10^5`
- `0 <= gas[i], cost[i] <= 10^4`
- 输入保证若存在解则唯一。

---

## 💡 评测流程（伪代码）

```c
int start = canCompleteCircuit(gas, cost);
if (start == -1) {
    // 任何起点都无法完成一圈
} else {
    int tank = 0;
    for (int k = 0; k < n; k++) {
        int i = (start + k) % n;
        tank += gas[i] - cost[i];
        assert(tank >= 0); // 全程油量不为负
    }
    assert((start + n - 1) % n == (start - 1 + n) % n); // 确认回到起点
}
```

只要总油量 `sum(gas) - sum(cost) >= 0` 并找到一个油箱从未跌破 0 的起点，就能保证整圈通行。


