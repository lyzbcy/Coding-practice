## 初次提交代码

```c
int trap(int* height, int heightSize) {



    /*

    思路：从1开始到heightSize-2遍历

    如果第n项开始，可以往后找到一个m>=n，那从n->m这一段就是水池

    这一段水池的容量就等于从n+1项一直到m-1项，（水池高度(n)-每一项）的累加

    */

    int water=0;

    for(int i=1;i<heightSize-1;i++){

        int slow=i;

        int fast=i+1;

        while(height[fast]<height[slow]){

            fast++;

            if(fast>=heightSize){

                goto nextone;

            }

        }

        int poolheight=height[slow];

        while(slow<(fast-1)){

            slow++;

            water+=poolheight-height[slow];

        }

        

    nextone:;

    }

    return water;

}
```

## 批阅意见

1. `while (height[fast] < height[slow])` 在进入循环前就访问 `height[fast]`，但 `fast` 初值为 `i + 1`，当 `i = heightSize - 2` 时第一次访问就是越界读，未做任何边界判定。
2. 「池壁高度」直接使用左端 `poolheight = height[slow]`，却没有与右边界取 `min`，当右侧柱子比左侧矮时，公式 `poolheight - height[slow]` 会变成负数或夸大水量，逻辑并不符合木桶原理。
3. 通过 `goto` 跳转来模仿“找不到右边界就放弃”，但这会把所有位于全局最高柱左侧的水量全部舍弃，与正确答案 6/9 相差巨大。
4. 双层 while 搜索导致最坏情况下接近 `O(n^2)`，题目给出的 `n` 可达 2 * 10^4，暴力扫描会超时。
5. 变量 `slow` 被复用于遍历和积水统计，使得 `water += poolheight - height[slow]` 实际计算的是“左端减去中间值”，而不是左右边界之间的差值，建议重新推导「min(leftMax, rightMax) - height[i]」后再写。

---

请先理清「短板决定水位」的条件，再参考教学文档中的双指针或单调栈实现，逐步修正边界判断与整体结构。



