# LeetCode 42. 接雨水 - 详细教学文档

## 📚 目录

1. [问题分析](#问题分析)
2. [思路解析](#思路解析)
3. [算法详解](#算法详解)
4. [代码实现](#代码实现)
5. [复杂度分析](#复杂度分析)
6. [常见错误](#常见错误)
7. [扩展思考](#扩展思考)

---

## 问题分析

### 题目要求

- 输入：一维数组 `height`，表示宽度为 1 的立柱高度。
- 输出：降雨后可接住的水量总和。
- 限制：`1 <= n <= 2 * 10^4`，`0 <= height[i] <= 10^5`。
- 期望：在 `O(n)` 时间内完成，最好只使用 `O(1)` 或 `O(n)` 额外空间。

### 核心观察

任意位置 `i` 能够蓄水的高度为 `min(maxLeft(i), maxRight(i)) - height[i]`，其中 `maxLeft(i)` 是 `i` 左侧（含本身）柱子的最高高度，`maxRight(i)` 为右侧最高值。若结果为负，则表示无法积水，取 0。

---

## 思路解析

### 错误直觉 ❌

1. **暴力枚举左右边界**  
   三重循环寻找每个位置左右更高的柱子，时间复杂度 `O(n^3)`，远超限制。
2. **仅凭全局最高柱判断**  
   只看最大值与当前位置的差异，忽略了另一侧边界，导致在「凹槽」的右半部分计算失真。
3. **从左往右单向扫描**  
   若只记录左侧最高值而忽略右侧，同样会在右半边缺乏约束，计算偏大。

### 正确思路 ✅

1. **前后缀数组**  
   预处理 `prefixMax[i]` 与 `suffixMax[i]`，每个位置一次 O(1) 计算，整体 O(n) 时间、O(n) 空间。
2. **单调栈**  
   使用递减栈保存高度索引，只要遇到更高柱子便弹出并计算封闭的水量。适合与「柱状图」家族题目一起练。
3. **双指针 + 动态维护最大值（推荐）**  
   左右指针从两端向中间收缩，始终让「较低一侧」向内移动，因为此时可确定当前水位由这一侧决定。额外空间 O(1)，实现简洁。

---

## 算法详解

以下重点展示双指针方案：

1. **初始化**
   - `left = 0`, `right = n - 1`
   - `leftMax = rightMax = 0`
   - `water = 0`

2. **循环条件 `left < right`**
   - 若 `height[left] < height[right]`：
     - 更新 `leftMax = max(leftMax, height[left])`
     - 当前列贡献 `leftMax - height[left]`
     - `left++`
   - 否则（右侧更低或相等）：
     - 更新 `rightMax = max(rightMax, height[right])`
     - 贡献 `rightMax - height[right]`
     - `right--`

3. **结束**
   - 当左右指针相遇，所有位置均已处理，返回 `water`。

### 关键理由

- 「水位由短板决定」意味着，只要我们能确认某一侧的最高高度与另一侧当前高度的关系，就能立刻得出该列的水量。
- 由于外层柱子高度越高越容易封闭凹槽，向内收缩的顺序必须始终选择较低一侧，保证计算不依赖未知的另一侧信息。

---

## 代码实现

### C 版本

```c
int trap(int* height, int heightSize) {
    if (height == NULL || heightSize <= 2) {
        return 0;
    }
    int left = 0, right = heightSize - 1;
    int leftMax = 0, rightMax = 0;
    int water = 0;
    while (left < right) {
        if (height[left] < height[right]) {
            leftMax = leftMax > height[left] ? leftMax : height[left];
            water += leftMax - height[left];
            left++;
        } else {
            rightMax = rightMax > height[right] ? rightMax : height[right];
            water += rightMax - height[right];
            right--;
        }
    }
    return water;
}
```

### C++ 版本

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        const int n = height.size();
        if (n <= 2) return 0;
        int left = 0, right = n - 1;
        int leftMax = 0, rightMax = 0;
        int water = 0;
        while (left < right) {
            if (height[left] < height[right]) {
                leftMax = max(leftMax, height[left]);
                water += leftMax - height[left];
                left++;
            } else {
                rightMax = max(rightMax, height[right]);
                water += rightMax - height[right];
                right--;
            }
        }
        return water;
    }
};
```

---

## 复杂度分析

- **时间复杂度：** `O(n)`，双指针各自最多移动 `n` 次。
- **空间复杂度：** `O(1)`，仅使用常数个辅助变量。

若使用前后缀数组，则空间复杂度为 `O(n)`；单调栈同样需要 `O(n)` 栈空间。

---

## 常见错误

1. **只记录单侧最大值**：没有右侧最大值约束，计算会过大。
2. **等高时不收缩右侧**：导致死循环或重复计算，分支条件必须包含等号。
3. **水量出现负值**：应确保加法前已经取 `max(leftMax, height[left])`，避免出现负贡献。
4. **忽略小数组**：`n <= 2` 时无法蓄水，应直接返回 0。
5. **累加时使用 `int` 但无溢出检查**：本题上限为 `n * 10^5`，在 32 位整型范围内，但若用于扩展题要注意改用 64 位。

---

## 扩展思考

1. **二维接雨水（LeetCode 407）**  
   需要用最小堆或 BFS 思路，维护外围边界后逐步向内更新水位。
2. **柱状图最大矩形（LeetCode 84）**  
   同样围绕「左右边界」展开，可借助单调栈思维迁移。
3. **如何输出每个位置的单独水量？**  
   在动画或调试中可以保存 `water[i]`，帮助定位错误。
4. **与盛最多水的容器（LeetCode 11）的联系**  
   两者都使用双指针，但前者统计面积，后者统计体积；理解差异有助于双指针题型归纳。

---

掌握两端夹逼的思路后，多多手画高度图和水位线，可以显著提升直觉。配合动画文件逐帧观察，更容易理解每一次指针移动的含义。祝你刷题顺利！💪



