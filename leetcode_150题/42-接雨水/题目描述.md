# 42. 接雨水

题目来源：https://leetcode.cn/problems/trapping-rain-water/

---

## 📝 题目描述

给定 `n` 个非负整数组成的数组 `height`，每个元素表示宽度为 1 的竖直柱子的高度。假设雨水从上方倾泻而下，问这些柱子在雨停后最多能积存多少单位的水。

蓄水规则：

1. 柱子之间形成的凹槽可以储水，水面高度由相邻左右两侧的最高边界中较小者决定。
2. 首尾两根柱子因为缺少一侧边界，无法储水。
3. 忽略由于浮点误差造成的细小间隙，答案保证为整数。

---

## ✅ 输出规范

- 函数签名：`int trap(int* height, int heightSize)` / `int trap(vector<int>& height)`
- 返回值：蓄水量总和（单位面积格子数量）
- 输入数组不会被修改；若需额外空间，必须在题目允许的范围内控制复杂度。

---

## 🔢 示例

### 示例 1

**输入：**  
`height = [0,1,0,2,1,0,1,3,2,1,2,1]`

**输出：** `6`

**说明：**  
可以视作 12 根不同高度的柱子。位置 2、4、5、6、9、10 处分别积水 `1,1,2,1,1,0`，合计 6。

---

### 示例 2

**输入：**  
`height = [4,2,0,3,2,5]`

**输出：** `9`

**说明：**  
右端最高柱子高度为 5，左端为 4。中间形成两个凹槽，积水量依次为 `2,4,1,2`，总计 9。

---

## 📌 提示 / 约束

- `n == height.length`
- `1 <= n <= 2 * 10^4`
- `0 <= height[i] <= 10^5`
- 期望时间复杂度 `O(n)`，额外空间最好控制在 `O(1)` 或 `O(n)`
- 输入规模较大，避免使用三重循环等高复杂度算法

---

## 💡 评测流程 / 伪代码

评测机会调用你的函数并对返回的整数进行断言：

```c
int data[] = {...};
int ans = trap(data, sizeof(data) / sizeof(int));
assert(ans == expected);
```

若希望快速验证思路，可参考两端夹逼的伪代码：

```
left = 0, right = n - 1
leftMax = rightMax = 0, water = 0
while left < right:
    if height[left] < height[right]:
        leftMax = max(leftMax, height[left])
        water += leftMax - height[left]
        left++
    else:
        rightMax = max(rightMax, height[right])
        water += rightMax - height[right]
        right--
return water
```

--- 

掌握「短板决定水位」之后，再尝试单调栈、前后缀数组等不同写法，可以帮助你在更多柱状图模型题中举一反三。



