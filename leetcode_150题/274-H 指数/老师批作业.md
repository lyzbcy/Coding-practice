# 老师批作业

> 本文件用于记录学生代码的批阅过程。当学生提交初次题解后，老师会在这里记录批阅意见。

---

## 📝 批阅说明

- 初次提交代码：记录学生的第一次尝试
- 批阅意见：指出代码中的问题、优点和改进建议
- 第二次提交代码：如果学生修改后再次提交，记录新的代码
- 批阅意见：对修改后的代码进行评价

---

## 🎯 批阅标准

- **正确性**：代码是否能通过所有测试用例
- **时间复杂度**：是否达到最优（O(n) 或 O(n log n)）
- **空间复杂度**：是否达到最优（O(1) 或 O(1) 固定空间）
- **代码风格**：变量命名、注释、可读性
- **算法思路**：是否使用了正确的排序或计数方法

---

## 📌 待学生提交代码

请将你的初次题解代码粘贴到下方，老师会进行批阅。

---

## 📋 学生提交记录

### 第一次提交


**学生代码**：

```c
int hIndex(int* citations, int citationsSize) {
    //思路：先进行递减排序，然后与从1开始递增排序进行比较 什么时候比不过，那就返回值
    
    for(int i=0;i<citationsSize;i++){
        int max=citations[i];
        int max_num=i;
        for(int j =i;j<citationsSize;j++){
            if(citations[j]>max){
                max=citations[j];
                max_num=j;
            }
        }
        // 交换
        int temp = citations[i];
        citations[i] = citations[max_num];
        citations[max_num] = temp;
    }
    
    // 然后比较
    for(int i=0;i<citationsSize;i++){
        if(citations[i] < i+1){
            return i;
        }
    }
    return citationsSize;
}
```

---

### 📝 批阅意见

#### ✅ 优点

1. **思路正确**：理解 H 指数的定义，知道需要先排序再比较
2. **算法逻辑正确**：排序后遍历比较的思路是对的
3. **边界处理**：考虑了所有论文都满足的情况（返回 `citationsSize`）
4. **代码结构清晰**：分为排序和比较两个阶段，逻辑分明

#### ❌ 问题分析

**问题 1：时间复杂度过高**
```c
for(int i=0;i<citationsSize;i++){
    int max=citations[i];
    int max_num=i;
    for(int j =i;j<citationsSize;j++){  // ❌ O(n²) 的选择排序
        if(citations[j]>max){
            max=citations[j];
            max_num=j;
        }
    }
    // 交换
    ...
}
```
- **问题**：使用了选择排序，时间复杂度为 O(n²)
- **原因**：选择排序需要两层循环，效率较低
- **正确做法**：使用标准库的快速排序 `qsort`，时间复杂度 O(n log n)

**问题 2：没有使用标准库排序**
- **问题**：手动实现排序，代码冗长且效率低
- **正确做法**：C 语言可以使用 `qsort`，C++ 可以使用 `sort`

**问题 3：代码注释不够详细**
- **问题**：注释较少，特别是比较逻辑部分
- **建议**：添加更详细的注释，说明为什么 `citations[i] < i+1` 时返回 `i`

#### 💡 算法思路问题

当前代码的思路是**正确的**，但实现效率不高。

**正确的思路（排序法）**：
1. 降序排序数组
2. 遍历数组，找到最大的 `i` 使得 `citations[i] >= i + 1`
3. 如果 `citations[i] < i + 1`，返回 `i`；否则返回 `citationsSize`

**更优的思路（计数排序法）**：
由于 `citations[i] <= 1000`，可以使用计数排序优化到 O(n)：
1. 统计每个引用次数的论文数量
2. 从高到低累加，找到最大的 `h` 使得累计论文数 ≥ `h`

#### 📊 测试用例验证

以 `citations = [3,0,6,1,5]` 为例：

**你的代码执行过程**：
- 排序后：`[6,5,3,1,0]`
- i=0: citations[0]=6 >= 1，继续
- i=1: citations[1]=5 >= 2，继续
- i=2: citations[2]=3 >= 3，继续
- i=3: citations[3]=1 < 4，返回 3

**结果**：返回 3（正确 ✓）

#### 🎯 改进建议

1. **使用标准库排序**：使用 `qsort` 替代手动选择排序
2. **优化时间复杂度**：从 O(n²) 优化到 O(n log n)
3. **考虑计数排序**：如果追求最优时间复杂度，可以使用计数排序优化到 O(n)
4. **添加详细注释**：特别是比较逻辑部分，说明为什么这样判断

#### 📝 参考正确代码

**方法一：排序法（推荐理解）**

```c
#include <stdlib.h>

// 比较函数：降序排序
int compare(const void* a, const void* b) {
    return *(int*)b - *(int*)a;
}

int hIndex(int* citations, int citationsSize) {
    // 降序排序
    qsort(citations, citationsSize, sizeof(int), compare);
    
    // 遍历查找最大的 h
    for (int i = 0; i < citationsSize; i++) {
        if (citations[i] < i + 1) {
            return i;
        }
    }
    return citationsSize;
}
```

**方法二：计数排序法（最优时间复杂度）**

```c
int hIndex(int* citations, int citationsSize) {
    // 计数数组：统计每个引用次数的论文数量
    int count[1001] = {0};
    
    // 统计频次（超过 n 的按 n 计算）
    for (int i = 0; i < citationsSize; i++) {
        if (citations[i] > citationsSize) {
            count[citationsSize]++;
        } else {
            count[citations[i]]++;
        }
    }
    
    // 从高到低累加，找到最大的 h
    int sum = 0;
    for (int h = citationsSize; h >= 0; h--) {
        sum += count[h];
        if (sum >= h) {
            return h;
        }
    }
    return 0;
}
```

#### 🌟 鼓励

你的思路完全正确！理解 H 指数的定义并正确实现了算法。主要问题是时间复杂度可以优化。建议先掌握排序法（使用标准库），理解后再学习计数排序法。继续加油！

---
