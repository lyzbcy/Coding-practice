# 238. 除自身以外数组的乘积

题目来源：https://leetcode.cn/problems/product-of-array-except-self/

---

## 📝 题目描述

给你一个整数数组 `nums`，请构造一个等长数组 `answer`，其中：

```
answer[i] = ∏_{j != i} nums[j]
```

也就是 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外所有元素的乘积。

要求：

1. 不得使用除法。
2. 时间复杂度需为 O(n)。
3. 题目保证任意前缀积与后缀积都在 32 位有符号整数范围内。

---

## ✅ 输出规范

- 返回一个与 `nums` 等长的新数组 `answer`。
- 设 `returnSize` 为输出数组长度，需设置 `*returnSize = numsSize`（C 版本）。
- `answer[i]` 必须是 32 位有符号整数范围内的数值。

---

## 🔢 示例

### 示例 1

**输入：**  
`nums = [1,2,3,4]`

**输出：**  
`[24,12,8,6]`

**说明：**  
`answer[0] = 2×3×4 = 24`，`answer[1] = 1×3×4 = 12`，以此类推。

---

### 示例 2

**输入：**  
`nums = [-1,1,0,-3,3]`

**输出：**  
`[0,0,9,0,0]`

**说明：**  
唯一的 0 出现在索引 2，因此只有 `answer[2]` 能得到非 0 值（乘上所有非 0 元素后为 9），其余位置都带上这个 0，结果为 0。

---

## 📌 提示 / 约束

- `2 <= nums.length <= 10^5`
- `-30 <= nums[i] <= 30`
- 输入保证 `answer[i]` 在 32 位有符号整数范围内
- 进阶要求：除输出数组外使用 O(1) 额外空间

---

## 💡 评测流程（伪代码）

以下伪代码展示了评测系统对你函数的调用方式：

```c
int nums[] = {...};
int returnSize = 0;

int* answer = productExceptSelf(nums, numsSize, &returnSize);
assert(returnSize == numsSize);

for (int i = 0; i < numsSize; i++) {
    // 检查 answer[i] 是否等于除自身以外所有元素的乘积
    // 评测机会针对不同输入重复上述校验
}
free(answer);
```

---

**目标：** 通过一趟前缀积和一趟后缀积的方式，在线性时间和常数额外空间内完成计算。





