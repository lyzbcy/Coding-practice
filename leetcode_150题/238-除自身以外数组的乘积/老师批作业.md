## 初次提交代码

```c
int* productExceptSelf(int* nums, int numsSize, int* returnSize) {
    /*
    思路：呃呃 那就遍历呗 从i+1项开始，一直到i+numsSize项，定义一个current，current=i+1，如果current>=numsSize，current-=numsSize
    */
    int *returnSize=(int*)malloc(sizeof(int)*numsSize);
    for(int i=0;i<numsSize;i++){
        int current =i;
        returnSize[i]=1;
        for(int j=1;j<numsSize;j++){
            current=i+j;
            if(current>=numsSize){
                current-=numsSize;
            }
            returnSize[i]=returnSize[i]*nums[current];
        }
    }
    return returnSize;
}
```

## 批阅意见

1. 重新定义了 `int *returnSize` 局部变量，与形参 `int* returnSize` 同名，导致调用者传入的 `returnSize` 无法被写入正确长度，且原本的指针直接丢失，属于未定义行为。
2. 题目明确要求 O(n) 时间，这段代码对每个 `i` 再跑一圈内层循环，时间复杂度 O(n²)，在 `numsSize = 10^5` 时无法通过。
3. `current` 的“绕圈”写法相当于手动取模，但依旧会把 `nums[i]` 本身乘进去，与“除自身以外”的要求冲突。
4. 没有处理含 0 的数组。若 `nums` 中出现 0，直接相乘会导致某些元素应为非零却被 0 覆盖。
5. 缺少基本的内存安全：没有判空、没有检查 `malloc` 返回值，也没有在失败时提前退出。更重要的是函数结束后没有设置 `*returnSize = numsSize`。

> 建议：改用“前缀积 + 后缀积”两趟扫描的套路。第一趟写入左侧乘积，第二趟乘上右侧乘积，既满足 O(n) 时间，又只占用常数额外空间。




