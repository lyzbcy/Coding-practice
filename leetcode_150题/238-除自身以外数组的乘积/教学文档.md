# LeetCode 238. 除自身以外数组的乘积 - 教学文档

## 📚 目录

1. [问题分析](#问题分析)
2. [思路解析](#思路解析)
3. [算法详解](#算法详解)
4. [代码实现](#代码实现)
5. [复杂度分析](#复杂度分析)
6. [常见错误](#常见错误)
7. [扩展思考](#扩展思考)

---

## 问题分析

### 题目要求

- 输入一个长度为 `n` 的整数数组 `nums`。
- 构造数组 `answer`，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 外所有元素的乘积。
- 不允许使用除法。
- 必须在 O(n) 时间内完成。

### 关键约束

1. `n` 最多 10^5，必须线性时间。
2. 输出数组不计入额外空间，可以用它来暂存前缀积。
3. `nums[i]` 在 [-30, 30] 范围，可能包含 0，需慎重处理。

---

## 思路解析

### 错误直觉 ❌

1. **直接求总乘积再除以 `nums[i]`**  
   - 当存在 0 时会崩溃。
   - 题目显式禁止使用除法。
2. **对每个位置都重新遍历一遍**  
   - 时间复杂度 O(n²)，在 n=10^5 时无法通过。

### 正确思路 ✅

利用 **前缀积 + 后缀积**：

- `answer[i] = 左侧所有元素乘积 × 右侧所有元素乘积`
- 先从左到右扫描，记录当前位置左侧的乘积；再从右到左扫描，乘上右侧乘积。
- 两次扫描均只使用一个累计变量，因此额外空间为 O(1)。

伪代码：

```
answer = [1] * n
prefix = 1
for i in [0, n):
    answer[i] = prefix
    prefix *= nums[i]

suffix = 1
for i in [n-1, -1]:
    answer[i] *= suffix
    suffix *= nums[i]
```

---

## 算法详解

1. **初始化**  
   - 申请长度为 `n` 的数组 `answer`，暂存前缀积。
   - `prefix = 1` 表示当前索引左侧所有数的乘积。

2. **第一趟：写入前缀积**  
   - 遍历 i 从 0 到 n-1。  
   - `answer[i] = prefix`，即记录“左边的积”。  
   - 然后 `prefix *= nums[i]`，为下一个位置准备。

3. **第二趟：乘上后缀积**  
   - `suffix = 1`，表示当前索引右侧所有数的乘积。  
   - i 从 n-1 递减到 0：  
     - `answer[i] *= suffix`，此时拿到左×右的完整结果。  
     - `suffix *= nums[i]`，为左边的元素准备“右侧积”。

4. **返回结果**  
   - 此时 `answer[i]` 已满足题意，直接返回。

### 为什么能处理 0？

- 如果数组里没有 0，前缀 × 后缀即为除自身以外的乘积。
- 如果存在一个 0，只有包含该 0 的位置会在两次扫描中获得左右两个非零乘积，其余位置至少有一侧乘积为 0。
- 如果有两个及以上的 0，所有位置都会在左或右乘到 0，自然全为 0。

---

## 代码实现

### C 语言关键实现

```c
int* productExceptSelf(int* nums, int numsSize, int* returnSize) {
    *returnSize = numsSize;
    int* ans = (int*)malloc(sizeof(int) * numsSize);
    int prefix = 1;
    for (int i = 0; i < numsSize; i++) {
        ans[i] = prefix;
        prefix *= nums[i];
    }
    int suffix = 1;
    for (int i = numsSize - 1; i >= 0; i--) {
        ans[i] *= suffix;
        suffix *= nums[i];
    }
    return ans;
}
```

### C++ 版本

```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, 1);
        int prefix = 1;
        for (int i = 0; i < n; ++i) {
            ans[i] = prefix;
            prefix *= nums[i];
        }
        int suffix = 1;
        for (int i = n - 1; i >= 0; --i) {
            ans[i] *= suffix;
            suffix *= nums[i];
        }
        return ans;
    }
};
```

---

## 复杂度分析

- **时间复杂度：** O(n)  
  两次线性扫描，各访问元素一次。
- **空间复杂度：** O(1) 额外空间  
  只使用常数个变量 `prefix`、`suffix`，输出数组不计入。

---

## 常见错误

1. **遗漏 `returnSize` 的设置**  
   - 在 C 版本里忘记 `*returnSize = numsSize` 会导致平台判题失败。
2. **前缀或后缀更新顺序写反**  
   - 必须先写入 `answer[i]` 再更新 `prefix`/`suffix`，否则会包含当前位置自身。
3. **不考虑 0**  
   - 若使用“总积 / nums[i]”的思路，在出现 0 时无法处理。
4. **额外申请前缀、后缀数组**  
   - 能通过但空间为 O(n)，不满足进阶要求。

---

## 扩展思考

1. **可否推广到二维矩阵？**  
   - 思想相同，只需对行列方向维护前缀与后缀积。
2. **与前缀和的关系**  
   - 两者都是“拆掉当前元素”的技巧，区别在于运算由加法换成乘法。
3. **如何避免溢出？**  
   - 题目已保证不溢出，但在其他题目中应考虑使用 64 位整数或模数乘法。

---

熟练掌握两趟扫描后，看到“对每一位求除自身以外的聚合结果”这类题目，就能迅速想到“前缀 + 后缀”的范式。👍





