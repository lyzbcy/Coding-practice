## 初次提交代码

```c
int removeElement(int* nums, int numsSize, int val) {
    char c;
    c=nums[0];
    int i=0;
    int k=0;
    while(c=getchar(nums[i])!=Null||c>(numsSize-k)){
        if(num[i]==val){
            int a=num[i];
            nums[i]=nums[numsSize-1-k];
            nums[numsSize-1-k]=a;
        }
        else{
            i++;
        }
    }
    return k;
}
```

## 批阅意见

1. `while (c = getchar(nums[i]) != Null || …)` 中使用了 `getchar` 和 `Null`，会直接编译失败且逻辑偏离题意；移除元素并不需要字符输入。
2. `num[i]` 多次拼写错误，应为 `nums[i]`，否则变量未定义，程序无法通过编译。
3. 变量 `k` 初始化为 0 却从未改变，最终返回值必定为 0，不能反映移除后的长度。
4. `char c = nums[0];` 类型不匹配且没有意义，循环也未对 `i`、`k` 做边界控制，容易越界或死循环。
5. 交换逻辑没有同步移动尾指针或重新检查当前位置，也没有遵循“快慢指针覆盖”或“尾部缩短”中的任一规范流程。

## 第二次提交代码

```c
int removeElement(int* nums, int numsSize, int val) {

    int slow = 0;

    int fast = 0;

    while(nums[fast]!=Null){

        if(nums[fast]==val){

            fast++;

            continue;

        }

        if(nums[slow]==val){

            nums[slow]=nums[fast];

            slow++;

            fast++;

        }

    }

    return (slow+1);

}
```

## 第二次批阅意见

1. `while (nums[fast] != Null)` 仍然使用了 `Null` 并企图以数组值作为终止条件，既不符合 C 语言语法（应使用 `NULL` 指针或数值比较）也无法防止越界，正确做法应以 `fast < numsSize` 控制。
2. 当前循环在遇到 `nums[fast] != val` 且 `nums[slow] != val` 时既不移动 `slow` 也不移动 `fast`，会立即陷入死循环，说明缺失“快慢指针同步前进”的分支。
3. `slow` 只在 `nums[slow] == val` 时递增，无法统计被保留元素的数量；返回 `slow + 1` 也与题意不符，因为 `slow` 已经是待写入位置索引，不应再加一。
4. 缺失对 `numsSize` 为 0 的处理以及对 `fast` 递增的最终出口，整体结构还未与教学中的标准双指针逻辑对齐，建议回到伪代码重新梳理。

