# LeetCode 392. 判断子序列 - 详细教学文档

## 📚 目录

1. [问题分析](#问题分析)
2. [思路解析](#思路解析)
3. [算法详解](#算法详解)
4. [代码实现](#代码实现)
5. [复杂度分析](#复杂度分析)
6. [常见错误](#常见错误)
7. [扩展思考](#扩展思考)

---

## 问题分析

### 题目要求

- 给定两个字符串 `s` 和 `t`
- 判断 `s` 是否为 `t` 的子序列
- 子序列的定义：可以通过删除 `t` 中的一些字符得到 `s`，且字符的相对顺序必须保持不变

### 关键约束

1. **字符串长度**：
   - `s.length <= 100`
   - `t.length <= 10^4`
   - 需要 O(n) 或更优的算法

2. **字符类型**：两个字符串都只由小写字符组成

3. **子序列特性**：
   - 不需要连续，但必须按顺序出现
   - 例如：`"ace"` 是 `"abcde"` 的子序列（位置 0, 2, 5）
   - 但 `"aec"` 不是（因为 `'e'` 在 `'c'` 之后，顺序不对）

---

## 思路解析

### 错误直觉 ❌

- **暴力匹配**：尝试所有可能的子序列组合，时间复杂度 O(2^n)，不可行
- **使用哈希表记录位置**：虽然可以，但过于复杂，不符合简单题的要求
- **先排序再比较**：排序会破坏相对顺序，完全错误
- **只检查字符是否存在**：忽略了顺序要求，例如 `"axc"` 中 `'a'` 和 `'c'` 都存在，但中间没有 `'x'`

### 正确思路 ✅

本题的核心是**贪心算法** + **双指针**：

1. **贪心思想**：对于 `s` 中的每个字符，在 `t` 中找**最早出现**的匹配位置
2. **双指针**：
   - `i` 指向 `s` 的当前字符（需要匹配的字符）
   - `j` 指向 `t` 的当前字符（正在检查的位置）

3. **匹配策略**：
   - 如果 `s[i] == t[j]`，说明找到了 `s` 中的一个字符，`i++`，`j++`
   - 如果 `s[i] != t[j]`，说明 `t[j]` 不是我们需要的，只移动 `j++`（继续在 `t` 中寻找）

4. **判断结果**：
   - 如果 `i` 到达 `s` 的末尾，说明 `s` 的所有字符都在 `t` 中按顺序找到了，返回 `true`
   - 如果 `j` 到达 `t` 的末尾但 `i` 还没到 `s` 的末尾，说明无法匹配，返回 `false`

伪代码：

```
i = 0  // s 的指针
j = 0  // t 的指针

while i < len(s) and j < len(t):
    if s[i] == t[j]:
        i++  // 找到了 s 中的一个字符
    j++  // 无论是否匹配，都要继续遍历 t

return i == len(s)  // 如果 i 到达末尾，说明全部匹配
```

---

## 算法详解

### 核心思想

**贪心匹配**：对于 `s` 中的每个字符，在 `t` 中从左到右找第一个匹配的位置。

### 执行步骤

1. **初始化指针**
   - `i = 0`：指向 `s` 的第一个字符
   - `j = 0`：指向 `t` 的第一个字符

2. **遍历匹配**
   - 如果 `s[i] == t[j]`：
     - 说明找到了 `s` 中的一个字符
     - `i++`：移动到 `s` 的下一个字符
     - `j++`：移动到 `t` 的下一个字符
   - 如果 `s[i] != t[j]`：
     - 说明 `t[j]` 不是我们需要的
     - 只移动 `j++`：继续在 `t` 中寻找

3. **结束条件**
   - 如果 `i == len(s)`：说明 `s` 的所有字符都找到了，返回 `true`
   - 如果 `j == len(t)` 但 `i < len(s)`：说明 `t` 遍历完了但 `s` 还没匹配完，返回 `false`

### 示例演示

**示例 1：** `s = "abc"`, `t = "ahbgdc"`

```
初始：i=0, j=0
s[0]='a', t[0]='a' → 匹配！i=1, j=1
s[1]='b', t[1]='h' → 不匹配，j=2
s[1]='b', t[2]='b' → 匹配！i=2, j=3
s[2]='c', t[3]='g' → 不匹配，j=4
s[2]='c', t[4]='d' → 不匹配，j=5
s[2]='c', t[5]='c' → 匹配！i=3, j=6
i=3 == len(s)=3 → 返回 true
```

**示例 2：** `s = "axc"`, `t = "ahbgdc"`

```
初始：i=0, j=0
s[0]='a', t[0]='a' → 匹配！i=1, j=1
s[1]='x', t[1]='h' → 不匹配，j=2
s[1]='x', t[2]='b' → 不匹配，j=3
s[1]='x', t[3]='g' → 不匹配，j=4
s[1]='x', t[4]='d' → 不匹配，j=5
s[1]='x', t[5]='c' → 不匹配，j=6
j=6 == len(t)=6，但 i=1 < len(s)=3 → 返回 false
```

### 为什么贪心策略是正确的？

- **局部最优**：对于 `s` 中的每个字符，选择 `t` 中最早出现的匹配位置
- **全局最优**：如果存在子序列，贪心策略一定能找到；如果不存在，贪心策略会最早发现无法匹配

---

## 代码实现

### C 语言核心代码

```c
#include <string.h>
#include <stdbool.h>

bool isSubsequence(char* s, char* t) {
    int i = 0;  // s 的指针
    int j = 0;  // t 的指针
    int len_s = strlen(s);
    int len_t = strlen(t);
    
    // 遍历 t，尝试匹配 s 中的每个字符
    while (i < len_s && j < len_t) {
        if (s[i] == t[j]) {
            i++;  // 找到了 s 中的一个字符
        }
        j++;  // 无论是否匹配，都要继续遍历 t
    }
    
    // 如果 i 到达 s 的末尾，说明全部匹配
    return i == len_s;
}
```

### C++ 实现

```cpp
#include <string>
using namespace std;

class Solution {
public:
    bool isSubsequence(string s, string t) {
        int i = 0;  // s 的指针
        int j = 0;  // t 的指针
        
        // 遍历 t，尝试匹配 s 中的每个字符
        while (i < s.length() && j < t.length()) {
            if (s[i] == t[j]) {
                i++;  // 找到了 s 中的一个字符
            }
            j++;  // 无论是否匹配，都要继续遍历 t
        }
        
        // 如果 i 到达 s 的末尾，说明全部匹配
        return i == s.length();
    }
};
```

### 优化版本（提前返回）

```c
bool isSubsequence(char* s, char* t) {
    int i = 0;
    int j = 0;
    int len_s = strlen(s);
    int len_t = strlen(t);
    
    // 如果 s 为空，直接返回 true
    if (len_s == 0) {
        return true;
    }
    
    // 如果 s 的长度大于 t，不可能匹配
    if (len_s > len_t) {
        return false;
    }
    
    while (j < len_t) {
        if (s[i] == t[j]) {
            i++;
            // 提前返回：如果已经匹配完 s 的所有字符
            if (i == len_s) {
                return true;
            }
        }
        j++;
    }
    
    return false;
}
```

---

## 复杂度分析

### 时间复杂度：O(n)

- `n` 是 `t` 的长度
- 最坏情况下需要遍历整个 `t` 字符串
- 每个字符最多被访问一次

### 空间复杂度：O(1)

- 只使用了两个指针变量 `i` 和 `j`
- 没有使用额外的数据结构

---

## 常见错误

1. **边界条件处理不当**
   - 空字符串 `s` 应该是任何字符串的子序列，返回 `true`
   - 如果 `s` 的长度大于 `t`，直接返回 `false`（可以提前判断）

2. **指针移动错误**
   - 错误：`if (s[i] == t[j]) { i++; j++; } else { j++; }`
   - 正确：`if (s[i] == t[j]) { i++; } j++;`（无论是否匹配，`j` 都要移动）

3. **重复判断条件**
   - 在循环内部和循环外部都判断 `i == len(s)`，可以优化
   - 建议：只在循环结束后判断一次

4. **使用 `strlen()` 的重复调用**
   - 错误：在循环中多次调用 `strlen(s)` 和 `strlen(t)`
   - 正确：先计算长度，存储在变量中

5. **理解错误：认为需要连续匹配**
   - 错误：认为 `s` 的字符必须在 `t` 中连续出现
   - 正确：只需要按顺序出现即可，不需要连续

---

## 扩展思考

### 1. 进阶问题：大量输入的优化

**问题描述：**  
如果有大量输入的 S（S1, S2, ..., Sk，k >= 10亿），需要依次检查它们是否为 T 的子序列。

**优化思路：**

#### 方法一：预处理 T，构建字符位置索引

```cpp
class Solution {
public:
    bool isSubsequence(string s, string t) {
        // 预处理：为 t 中的每个字符建立位置索引
        vector<vector<int>> pos(26);  // 26 个小写字母
        for (int i = 0; i < t.length(); i++) {
            pos[t[i] - 'a'].push_back(i);
        }
        
        // 对于每个 s，使用二分查找快速定位
        int current_pos = -1;  // 当前在 t 中的位置
        for (char c : s) {
            int idx = c - 'a';
            // 在 pos[idx] 中找第一个大于 current_pos 的位置
            auto it = upper_bound(pos[idx].begin(), pos[idx].end(), current_pos);
            if (it == pos[idx].end()) {
                return false;  // 找不到匹配的字符
            }
            current_pos = *it;
        }
        return true;
    }
};
```

**复杂度：**
- 预处理：O(n)，n 是 t 的长度
- 每次查询：O(m log k)，m 是 s 的长度，k 是字符在 t 中出现的次数
- 总体：对于大量查询，比双指针方法更高效

#### 方法二：动态规划（DP）

使用 DP 预处理，但空间复杂度较高，通常不推荐。

### 2. 相关题目

- **524. 通过删除字母匹配到字典里最长单词**  
  类似思路，但需要找到最长的匹配单词

- **792. 匹配子序列的单词数**  
  多个字符串判断子序列，可以使用预处理优化

- **1143. 最长公共子序列**  
  更复杂的问题，需要动态规划

### 3. 变种问题

- **如果要求连续子序列？**  
  使用滑动窗口，时间复杂度 O(n)

- **如果允许修改字符？**  
  变成编辑距离问题，需要动态规划

- **如果要求返回匹配的位置？**  
  在匹配时记录位置信息即可

---

**总结：** 本题是双指针 + 贪心算法的经典应用，核心思想是"贪心匹配"：对于 `s` 中的每个字符，在 `t` 中找最早出现的匹配位置。掌握本题后，可以轻松解决类似的字符串匹配问题。👍

