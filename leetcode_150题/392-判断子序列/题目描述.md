# 392. 判断子序列

题目来源：https://leetcode.cn/problems/is-subsequence/

---

## 📝 题目描述

给定字符串 `s` 和 `t`，判断 `s` 是否为 `t` 的子序列。

字符串的一个**子序列**是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"` 是 `"abcde"` 的一个子序列，而 `"aec"` 不是）。

**进阶：**

如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

**致谢：**

特别感谢 @pbrother 添加此问题并且创建所有测试用例。

---

## ✅ 输出规范

- 函数返回值：`bool` 类型
  - `true`：`s` 是 `t` 的子序列
  - `false`：`s` 不是 `t` 的子序列

- 处理要求：
  1. 子序列的定义：可以通过删除 `t` 中的一些字符得到 `s`
  2. 字符的相对顺序必须保持不变
  3. 不需要连续，但必须按顺序出现

---

## 🔢 示例

### 示例 1

**输入：**  
`s = "abc"`, `t = "ahbgdc"`

**输出：**  
`true`

**解释：**  
在 `t` 中，我们可以找到字符 `'a'`（位置 0）、`'b'`（位置 2）、`'c'`（位置 5），它们按顺序出现，所以 `"abc"` 是 `"ahbgdc"` 的子序列。

---

### 示例 2

**输入：**  
`s = "axc"`, `t = "ahbgdc"`

**输出：**  
`false`

**解释：**  
在 `t` 中，我们可以找到字符 `'a'`（位置 0）和 `'c'`（位置 5），但找不到 `'x'`，所以 `"axc"` 不是 `"ahbgdc"` 的子序列。

---

### 示例 3

**输入：**  
`s = ""`, `t = "ahbgdc"`

**输出：**  
`true`

**解释：**  
空字符串是任何字符串的子序列。

---

### 示例 4

**输入：**  
`s = "b"`, `t = "abc"`

**输出：**  
`true`

**解释：**  
`"b"` 在 `"abc"` 中出现，是子序列。

---

## 📌 提示

- `0 <= s.length <= 100`
- `0 <= t.length <= 10^4`
- 两个字符串都只由小写字符组成

---

## 💡 评测说明

评测机会按照以下流程验证你的代码：

```c
char* s = "...";
char* t = "...";
bool result = isSubsequence(s, t);
// 验证 result 是否正确
```

**处理步骤：**

1. 使用双指针遍历：
   - `i` 指向 `s` 的当前字符
   - `j` 指向 `t` 的当前字符

2. 匹配过程：
   - 如果 `s[i] == t[j]`，说明找到了 `s` 中的一个字符，`i++`，`j++`
   - 如果 `s[i] != t[j]`，说明 `t[j]` 不是我们需要的，只移动 `j++`

3. 判断结果：
   - 如果 `i` 到达 `s` 的末尾，说明 `s` 的所有字符都在 `t` 中按顺序找到了，返回 `true`
   - 如果 `j` 到达 `t` 的末尾但 `i` 还没到 `s` 的末尾，说明无法匹配，返回 `false`

---

**目标：** 找到一种 O(n) 时间复杂度、O(1) 额外空间的解法。

