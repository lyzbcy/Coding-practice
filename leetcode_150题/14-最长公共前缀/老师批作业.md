## 初次提交代码

```c
char* longestCommonPrefix(char** strs, int strsSize) {
    /*
    思路：双指针解答，一个指针指向strs[0]的第slow项，另一个指针指向strs[i]的第slow项，i从0到strsSize-1遍历，如果都相等，则slow++，直到有一个不相等就return slow
    */
    int slow=0;
    int i=0;
    for(;;){
        for(i=0;i<strsSize;i++){
            if(strs[0][slow]==strs[i][slow]){
                i++;
            }else{
                goto output;
            }
        }
        slow++;
    }
    output:;
    char out[slow];
    for(int j=0;j<slow;j++){
        out[j]=strs[0][j];
    }
    return out;
}
```

## 批阅意见

1. **返回局部数组（严重错误）**  
   ```c
   char out[slow];  // 错误！
   return out;
   ```
   - 这是**最严重的问题**：函数返回后，局部数组 `out` 的内存会被释放，返回的指针指向无效内存
   - 应该使用 `malloc` 动态分配内存，并在调用者处释放

2. **使用 `goto` 语句（不推荐）**  
   - 虽然可以工作，但 `goto` 会降低代码可读性
   - 应该使用 `return` 直接返回，逻辑更清晰

3. **内层循环逻辑错误**  
   ```c
   for(i=0;i<strsSize;i++){
       if(strs[0][slow]==strs[i][slow]){
           i++;  // 错误！这里会跳过某些字符串
       }else{
           goto output;
       }
   }
   ```
   - 问题1：`i++` 在 `if` 内部，会导致循环变量被重复递增，跳过某些字符串
   - 问题2：应该比较 `strs[0][slow]` 和 `strs[i][slow]`，但 `i` 从 0 开始，会和自己比较（`strs[0]` 和 `strs[0]`）
   - 正确做法：内层循环应该从 `i=1` 开始，且不要在 `if` 内部修改循环变量

4. **未检查数组越界**  
   - 在访问 `strs[i][slow]` 之前，必须检查 `slow < strlen(strs[i])`，否则可能越界
   - 如果某个字符串长度不足，应该立即返回当前公共前缀

5. **未处理空数组**  
   - 如果 `strsSize == 0`，访问 `strs[0]` 会导致程序崩溃
   - 应该在函数开始处检查边界条件

6. **外层循环缺少终止条件**  
   ```c
   for(;;){  // 无限循环
   ```
   - 虽然可以通过 `goto` 跳出，但应该使用更清晰的条件循环
   - 应该以第一个字符串的长度为上限：`for (slow = 0; slow < strlen(strs[0]); slow++)`

7. **变量初始化位置不当**  
   - `i` 在外层循环外初始化，但在内层循环中使用，容易造成混淆
   - 应该在内层循环中直接声明：`for (int i = 1; i < strsSize; i++)`

## 改进建议

### 正确的实现思路：

1. **边界检查**：先检查 `strsSize == 0`
2. **纵向扫描**：以第一个字符串为基准，遍历每个字符位置
3. **字符比较**：对于每个位置，检查所有其他字符串的对应字符
4. **动态分配**：使用 `malloc` 分配结果字符串的内存
5. **提前返回**：一旦发现不匹配或越界，立即返回当前公共前缀

### 修正后的核心逻辑：

```c
if (strsSize == 0) return "";

for (int i = 0; i < strlen(strs[0]); i++) {
    char c = strs[0][i];
    for (int j = 1; j < strsSize; j++) {
        if (i >= strlen(strs[j]) || strs[j][i] != c) {
            // 返回前 i 个字符（需要动态分配）
            char* result = malloc((i + 1) * sizeof(char));
            strncpy(result, strs[0], i);
            result[i] = '\0';
            return result;
        }
    }
}
// 所有字符都匹配，返回第一个字符串的副本
```

---

**关键提醒**：
- ✅ 必须使用 `malloc` 动态分配返回的字符串
- ✅ 必须检查数组越界（`i < strlen(strs[j])`）
- ✅ 内层循环从 `j=1` 开始（避免和自己比较）
- ✅ 不要在循环内部修改循环变量
- ❌ 不要返回局部数组
- ❌ 尽量避免使用 `goto`


