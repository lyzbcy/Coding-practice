# 老师批作业

> 本文件用于记录学生代码的批阅过程。当学生提交初次题解后，老师会在这里记录批阅意见。

---

## 📝 批阅说明

- 初次提交代码：记录学生的第一次尝试
- 批阅意见：指出代码中的问题、优点和改进建议
- 第二次提交代码：如果学生修改后再次提交，记录新的代码
- 批阅意见：对修改后的代码进行评价

---

## 🎯 批阅标准

- **正确性**：代码是否能通过所有测试用例
- **时间复杂度**：是否达到最优（O(n)）
- **空间复杂度**：是否达到最优（O(1)）
- **代码风格**：变量命名、注释、可读性
- **算法思路**：是否使用了正确的贪心算法（边界跳跃法）

---

## 📌 待学生提交代码

请将你的初次题解代码粘贴到下方，老师会进行批阅。

---

## 📋 学生提交记录

### 第一次提交


**学生代码**：

```c
int jump(int* nums, int numsSize) {
    int maxjump=1;
    int n=0;
    for(int i =0;i<numsSize;i++){
        int jump = i+nums[i]+1;
        if(maxjump>=numsSize){
            return n;
        }
        if(jump>maxjump){
            maxjump=jump;
            n++;
        }
    }
    return n;
}
```

---

### 📝 批阅意见

#### ✅ 优点

1. **代码简洁**：代码结构清晰，变量命名基本可读
2. **有边界检查意识**：注意到需要检查是否到达终点
3. **使用贪心思想**：尝试用贪心算法解决问题

#### ❌ 问题分析

**问题 1：初始值设置错误**
```c
int maxjump=1;  // ❌ 错误
```
- **问题**：`maxjump` 初始化为 1 不正确
- **原因**：从位置 0 开始，能到达的最远位置应该是 `0 + nums[0]`，而不是 1
- **正确做法**：应该初始化为 `0` 或 `nums[0]`

**问题 2：跳跃距离计算错误**
```c
int jump = i+nums[i]+1;  // ❌ 错误
```
- **问题**：这里多加了 1
- **原因**：从位置 `i` 能跳 `nums[i]` 步，最远到达位置 `i + nums[i]`（索引从 0 开始）
- **正确做法**：应该是 `i + nums[i]`

**问题 3：跳跃次数增加逻辑错误**
```c
if(jump>maxjump){
    maxjump=jump;
    n++;  // ❌ 错误：每次更新 maxjump 就增加跳跃次数
}
```
- **问题**：每次 `jump > maxjump` 就增加跳跃次数，这是错误的
- **原因**：应该使用**边界跳跃法**，只有在到达上一次跳跃的边界时，才需要增加跳跃次数
- **正确做法**：需要维护一个 `end` 变量表示上一次跳跃的边界，只有当 `i == end` 时才增加跳跃次数

**问题 4：循环范围错误**
```c
for(int i =0;i<numsSize;i++){  // ❌ 应该只遍历到 numsSize-1
```
- **问题**：遍历到了最后一个位置
- **原因**：最后一个位置是终点，不需要再跳
- **正确做法**：应该只遍历到 `numsSize - 1`

**问题 5：边界检查位置不当**
```c
if(maxjump>=numsSize){
    return n;  // ❌ 可能返回错误的跳跃次数
}
```
- **问题**：在循环开始就检查，但此时 `n` 可能还没有正确更新
- **原因**：应该在更新 `maxReach` 后检查，并且要确保跳跃次数是正确的

#### 💡 算法思路问题

当前代码的思路是：每次遇到更远的可达位置就增加跳跃次数。但这是**错误的贪心策略**。

**正确的思路（边界跳跃法）**：
1. 维护 `end`：上一次跳跃能到达的最远位置（边界）
2. 维护 `maxReach`：当前能到达的最远位置
3. 当 `i == end` 时，说明需要再跳一次，更新 `jumps++` 和 `end = maxReach`

#### 📊 测试用例验证

以 `nums = [2, 3, 1, 1, 4]` 为例：

**你的代码执行过程**：
- i=0: jump=0+2+1=3, maxjump=3, n=1
- i=1: jump=1+3+1=5, maxjump=5, n=2
- i=2: jump=2+1+1=4, maxjump=5, n=2
- i=3: jump=3+1+1=5, maxjump=5, n=2
- i=4: jump=4+4+1=9, maxjump=9, n=3

**结果**：返回 3（错误，正确答案是 2）

**正确执行过程**：
- i=0: maxReach=2, end=0, i==end → jumps=1, end=2
- i=1: maxReach=4, end=2, i!=end → 不增加跳跃
- i=2: maxReach=4, end=2, i==end → jumps=2, end=4
- i=3: maxReach=4, end=4, i!=end → 不增加跳跃（已到达终点）

**结果**：返回 2（正确）

#### 🎯 改进建议

1. **使用边界跳跃法**：维护 `end` 和 `maxReach` 两个变量
2. **修正初始值**：`maxReach` 初始化为 0
3. **修正计算**：`maxReach = max(maxReach, i + nums[i])`（不要加 1）
4. **修正循环范围**：只遍历到 `numsSize - 1`
5. **修正跳跃逻辑**：只有当 `i == end` 时才增加跳跃次数

#### 📝 参考正确代码

```c
int jump(int* nums, int numsSize) {
    int jumps = 0;        // 跳跃次数
    int end = 0;          // 上一次跳跃能到达的最远位置（边界）
    int maxReach = 0;     // 当前能到达的最远位置
    
    // 注意：只需要遍历到 numsSize - 1
    for(int i = 0; i < numsSize - 1; i++) {
        // 更新当前能到达的最远位置
        maxReach = (maxReach > i + nums[i]) ? maxReach : (i + nums[i]);
        
        // 如果到达边界，需要再跳一次
        if(i == end) {
            jumps++;
            end = maxReach;
        }
    }
    
    return jumps;
}
```

#### 🌟 鼓励

虽然代码有错误，但可以看出你理解了贪心算法的基本思想。边界跳跃法是这道题的核心，需要理解"什么时候需要增加跳跃次数"这个关键点。继续加油！

---

