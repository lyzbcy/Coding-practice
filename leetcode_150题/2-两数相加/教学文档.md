# LeetCode 2. 两数相加 - 详细教学文档

## 📚 目录

1. [问题分析](#问题分析)
2. [思路解析](#思路解析)
3. [算法详解](#算法详解)
4. [代码实现](#代码实现)
5. [复杂度分析](#复杂度分析)
6. [常见错误](#常见错误)
7. [扩展思考](#扩展思考)

---

## 问题分析

### 题目要求

- 给定两个非空链表，表示两个非负整数
- 数字按**逆序**存储（低位在前，高位在后）
- 将两个数相加，返回表示和的链表
- 结果链表同样采用逆序存储

### 关键约束

1. **链表非空**：两个链表至少各有一个节点
2. **节点值范围**：0 ≤ Node.val ≤ 9
3. **无前导零**：除了数字 0 本身，不会有前导零
4. **进位处理**：相加可能产生进位，需要正确处理

### 示例理解

以示例 1 为例：
- `l1 = [2,4,3]` 表示数字 **342**（逆序：2→4→3）
- `l2 = [5,6,4]` 表示数字 **465**（逆序：5→6→4）
- 342 + 465 = **807**
- 结果 `[7,0,8]` 表示 **807**（逆序：8→0→7）

---

## 思路解析

### 错误直觉 ❌

1. **先转换为整数再相加**：
   - 问题：链表可能很长（最多 100 个节点），转换为整数会溢出
   - 例如：100 个节点，每个节点值 9，数字会非常大

2. **直接在原链表上修改**：
   - 问题：两个链表长度可能不同，修改原链表会破坏输入
   - 题目要求返回新链表，不应该修改输入

3. **先反转链表再相加**：
   - 问题：逆序存储正是为了简化操作，不需要反转

### 正确思路 ✅

本题的核心是**模拟竖式加法**：

1. **从低位到高位逐位相加**（逆序存储正好符合这个顺序）
2. **维护进位变量** `carry`，初始为 0
3. **同时遍历两个链表**，直到两个链表都遍历完
4. **处理进位**：如果最后还有进位，创建新节点

伪代码：

```
carry = 0
dummy = 新节点（虚拟头节点）
current = dummy

while l1 != NULL 或 l2 != NULL 或 carry != 0:
    sum = carry
    if l1 != NULL:
        sum += l1.val
        l1 = l1.next
    if l2 != NULL:
        sum += l2.val
        l2 = l2.next
    
    carry = sum / 10
    digit = sum % 10
    
    创建新节点，值为 digit
    current.next = 新节点
    current = current.next

return dummy.next
```

---

## 算法详解

### 步骤 1：初始化

- 创建虚拟头节点 `dummy`，简化边界处理
- 初始化 `carry = 0`（进位）
- 初始化 `current` 指向 `dummy`（用于构建结果链表）

### 步骤 2：同时遍历两个链表

循环条件：`l1 != NULL || l2 != NULL || carry != 0`

- **为什么要包含 `carry != 0`？**  
  如果两个链表都遍历完了，但还有进位（如 999 + 1 = 1000），需要继续处理

### 步骤 3：计算当前位的和

```c
int sum = carry;  // 先加上进位
if (l1 != NULL) {
    sum += l1->val;
    l1 = l1->next;
}
if (l2 != NULL) {
    sum += l2->val;
    l2 = l2->next;
}
```

### 步骤 4：处理进位和当前位

```c
carry = sum / 10;      // 计算新的进位
int digit = sum % 10;  // 计算当前位的值
```

### 步骤 5：创建新节点并连接

```c
struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
newNode->val = digit;
newNode->next = NULL;
current->next = newNode;
current = current->next;
```

### 步骤 6：返回结果

返回 `dummy->next`（跳过虚拟头节点）

---

## 代码实现

### C 语言核心代码

```c
struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {
    // 创建虚拟头节点，简化边界处理
    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));
    dummy->val = 0;
    dummy->next = NULL;
    
    struct ListNode* current = dummy;
    int carry = 0;
    
    // 同时遍历两个链表，直到都遍历完且没有进位
    while (l1 != NULL || l2 != NULL || carry != 0) {
        int sum = carry;
        
        // 加上 l1 的当前位
        if (l1 != NULL) {
            sum += l1->val;
            l1 = l1->next;
        }
        
        // 加上 l2 的当前位
        if (l2 != NULL) {
            sum += l2->val;
            l2 = l2->next;
        }
        
        // 计算新的进位和当前位的值
        carry = sum / 10;
        int digit = sum % 10;
        
        // 创建新节点
        struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
        newNode->val = digit;
        newNode->next = NULL;
        current->next = newNode;
        current = current->next;
    }
    
    return dummy->next;
}
```

### C++ 实现

```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        // 创建虚拟头节点
        ListNode* dummy = new ListNode(0);
        ListNode* current = dummy;
        int carry = 0;
        
        // 同时遍历两个链表
        while (l1 != nullptr || l2 != nullptr || carry != 0) {
            int sum = carry;
            
            if (l1 != nullptr) {
                sum += l1->val;
                l1 = l1->next;
            }
            
            if (l2 != nullptr) {
                sum += l2->val;
                l2 = l2->next;
            }
            
            carry = sum / 10;
            int digit = sum % 10;
            
            current->next = new ListNode(digit);
            current = current->next;
        }
        
        return dummy->next;
    }
};
```

### 关键技巧

1. **虚拟头节点（Dummy Node）**：
   - 避免处理空链表的特殊情况
   - 统一处理第一个节点的创建

2. **循环条件**：
   - `l1 != NULL || l2 != NULL || carry != 0`
   - 确保所有情况都被处理

3. **进位处理**：
   - `carry = sum / 10`：计算新的进位
   - `digit = sum % 10`：计算当前位的值

---

## 复杂度分析

### 时间复杂度

- **O(max(m, n))**：其中 m 和 n 分别是两个链表的长度
- 需要遍历两个链表中较长的那个，最多遍历 max(m, n) 次

### 空间复杂度

- **O(max(m, n))**：结果链表的长度最多为 max(m, n) + 1（可能有进位）
- 除了结果链表，只使用了常数额外空间（carry、指针等）

---

## 常见错误

### 1. 忘记处理最后的进位

**错误代码：**
```c
while (l1 != NULL || l2 != NULL) {  // 缺少 carry != 0
    // ...
}
```

**问题**：如果最后还有进位（如 999 + 1），会丢失最高位。

**正确做法**：循环条件包含 `carry != 0`

### 2. 访问空指针

**错误代码：**
```c
while (l1 != NULL || l2 != NULL) {
    int sum = l1->val + l2->val;  // 如果其中一个为 NULL，会崩溃
    // ...
}
```

**问题**：当两个链表长度不同时，其中一个会先变成 NULL。

**正确做法**：先检查是否为 NULL 再访问

### 3. 修改原链表

**错误代码：**
```c
l1->val = (l1->val + l2->val) % 10;  // 直接修改原链表
```

**问题**：题目要求返回新链表，不应该修改输入。

**正确做法**：创建新节点构建结果链表

### 4. 忘记初始化 carry

**错误代码：**
```c
int carry;  // 未初始化，值不确定
```

**问题**：carry 的初始值不确定，可能导致错误。

**正确做法**：`int carry = 0;`

### 5. 循环中同时移动指针导致逻辑错误

**错误代码：**
```c
for (; l1 != NULL || l2 != NULL; l1 = l1->next, l2 = l2->next) {
    // 如果其中一个为 NULL，访问 next 会崩溃
}
```

**问题**：当其中一个链表遍历完时，继续访问 `next` 会出错。

**正确做法**：在循环内部分别判断并移动指针

---

## 扩展思考

### 1. 如果数字是正序存储的怎么办？

**题目**：LeetCode 445. 两数相加 II

- 数字正序存储（高位在前，低位在后）
- 解法：先反转链表，相加后再反转；或使用栈

### 2. 如何优化空间复杂度？

- 如果允许修改原链表，可以在较长的链表上直接修改
- 但题目要求返回新链表，所以必须创建新节点

### 3. 如何处理负数？

- 可以扩展题目，支持负数相加
- 需要判断符号，然后决定是相加还是相减

### 4. 如何优化代码？

- 使用更简洁的写法：
```c
int sum = carry + (l1 ? l1->val : 0) + (l2 ? l2->val : 0);
```

### 5. 递归解法

虽然迭代更直观，但也可以使用递归：

```c
struct ListNode* addTwoNumbersRecursive(struct ListNode* l1, struct ListNode* l2, int carry) {
    if (l1 == NULL && l2 == NULL && carry == 0) {
        return NULL;
    }
    
    int sum = carry;
    if (l1 != NULL) {
        sum += l1->val;
        l1 = l1->next;
    }
    if (l2 != NULL) {
        sum += l2->val;
        l2 = l2->next;
    }
    
    struct ListNode* node = (struct ListNode*)malloc(sizeof(struct ListNode));
    node->val = sum % 10;
    node->next = addTwoNumbersRecursive(l1, l2, sum / 10);
    
    return node;
}
```

---

**总结**：本题是链表操作的经典题目，核心是模拟竖式加法，注意处理进位和链表长度不同的情况。

