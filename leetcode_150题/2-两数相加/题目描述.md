# 2. 两数相加

题目来源：https://leetcode.cn/problems/add-two-numbers/

---

## 📝 题目描述

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

---

## ✅ 输出规范

- 函数返回一个新的链表，表示两个输入链表所表示数字的和
- 新链表同样采用逆序存储（低位在前，高位在后）
- 每个节点存储一位数字（0-9）
- 如果最高位有进位，需要创建新节点存储

---

## 🔢 示例

### 示例 1

**输入：**  
`l1 = [2,4,3]`, `l2 = [5,6,4]`

**输出：**  
`[7,0,8]`

**解释：**  
- `l1` 表示数字 342（逆序：2→4→3）
- `l2` 表示数字 465（逆序：5→6→4）
- 342 + 465 = 807
- 结果链表：7→0→8（逆序：8→0→7）

---

### 示例 2

**输入：**  
`l1 = [0]`, `l2 = [0]`

**输出：**  
`[0]`

**解释：**  
- 0 + 0 = 0
- 结果链表：0

---

### 示例 3

**输入：**  
`l1 = [9,9,9,9,9,9,9]`, `l2 = [9,9,9,9]`

**输出：**  
`[8,9,9,9,0,0,0,1]`

**解释：**  
- `l1` 表示数字 9999999
- `l2` 表示数字 9999
- 9999999 + 9999 = 10009998
- 结果链表：8→9→9→9→0→0→0→1（逆序：10009998）

---

## 📌 提示

- 每个链表中的节点数在范围 `[1, 100]` 内
- `0 <= Node.val <= 9`
- 题目数据保证列表表示的数字不含前导零

---

## 💡 评测说明

评测机会按照以下流程验证你的代码：

```c
struct ListNode* l1 = createList([2,4,3]);
struct ListNode* l2 = createList([5,6,4]);
struct ListNode* result = addTwoNumbers(l1, l2);
// 验证 result 是否等于 [7,0,8]
```

**目标：** 找到一种 O(max(m,n)) 时间复杂度、O(max(m,n)) 空间复杂度的解法，其中 m 和 n 分别是两个链表的长度。

---

## 🔑 关键点

1. **逆序存储的优势**：可以直接从低位开始相加，符合竖式加法的习惯
2. **进位处理**：需要维护一个进位变量 `carry`，初始为 0
3. **链表长度不同**：当一个链表遍历完时，继续处理另一个链表
4. **最后有进位**：如果最后还有进位，需要创建新节点

---

