# LeetCode 55. 跳跃游戏 - 详细教学文档

## 📚 目录

1. [问题分析](#问题分析)
2. [思路解析](#思路解析)
3. [算法详解](#算法详解)
4. [代码实现](#代码实现)
5. [复杂度分析](#复杂度分析)
6. [常见错误](#常见错误)
7. [扩展思考](#扩展思考)

---

## 问题分析

### 题目要求

- 给定非负整数数组 `nums`
- 初始位置在数组的第一个下标（索引 0）
- `nums[i]` 表示从位置 `i` 可以跳跃的**最大长度**
- 判断是否能够到达最后一个下标（索引 `numsSize - 1`）

### 关键约束

1. **跳跃规则**：从位置 `i` 最多可以跳 `nums[i]` 步，也可以跳更少的步数
2. **目标**：只需要判断能否到达，不需要知道具体路径
3. **数组长度**：最多 10^4，适合线性扫描

### 关键理解

- 如果从位置 `i` 能跳 `nums[i]` 步，那么可以到达位置 `i+1, i+2, ..., i+nums[i]`
- 例如：`nums[0] = 2`，可以从位置 0 跳到位置 1 或位置 2

---

## 思路解析

### 错误直觉 ❌

1. **回溯/DFS 尝试所有路径**：
   - 时间复杂度：O(2^n)，会超时
   - 空间复杂度：O(n)（递归栈）
   - 问题：不需要知道具体路径，这种方法过于复杂

2. **动态规划（自底向上）**：
   - 时间复杂度：O(n²)
   - 空间复杂度：O(n)
   - 问题：对于本题，贪心算法更优

3. **尝试所有可能的跳跃步数**：
   - 时间复杂度：可能是指数级
   - 问题：没有利用"只需要判断能否到达"的特性

### 正确思路 ✅

本题是经典的 **贪心算法** 应用：

**核心思想**：维护当前能到达的**最远位置** `maxReach`

- 遍历数组，对于每个位置 `i`：
  - 如果 `i > maxReach`，说明无法到达位置 `i`，返回 `false`
  - 否则，更新 `maxReach = max(maxReach, i + nums[i])`
  - 如果 `maxReach >= numsSize - 1`，说明可以到达终点，返回 `true`

**为什么贪心是正确的？**

- 我们只需要判断**能否到达**，不需要知道具体路径
- 如果从位置 `i` 能到达位置 `j`（`j <= i + nums[i]`），那么位置 `j` 之后的所有位置，都可以从位置 `i` 到达
- 所以只需要维护**能到达的最远位置**，不需要考虑具体怎么跳

---

## 算法详解

### 算法流程

1. **初始化**
   - `maxReach = 0`：表示当前能到达的最远位置（初始为 0，因为从位置 0 开始）

2. **遍历数组**
   - 对于每个位置 `i`（从 0 到 `numsSize - 1`）：
     - **检查可达性**：如果 `i > maxReach`，说明无法到达位置 `i`，返回 `false`
     - **更新最远位置**：`maxReach = max(maxReach, i + nums[i])`
     - **提前终止**：如果 `maxReach >= numsSize - 1`，说明可以到达终点，返回 `true`

3. **结束**
   - 如果遍历完整个数组，说明可以到达终点，返回 `true`

### 示例分析

#### 示例 1：`nums = [2,3,1,1,4]`

| i | nums[i] | i + nums[i] | maxReach | 说明 |
|---|---------|-------------|----------|------|
| 0 | 2 | 2 | 2 | 从位置0最多能到位置2 |
| 1 | 3 | 4 | 4 | 从位置1最多能到位置4（更新maxReach） |
| 2 | 1 | 3 | 4 | 从位置2最多能到位置3（不更新） |
| 3 | 1 | 4 | 4 | 从位置3最多能到位置4（不更新） |
| 4 | 4 | 8 | 8 | 从位置4最多能到位置8（超过终点） |

**结果**：`maxReach = 8 >= 4`，返回 `true` ✓

#### 示例 2：`nums = [3,2,1,0,4]`

| i | nums[i] | i + nums[i] | maxReach | 说明 |
|---|---------|-------------|----------|------|
| 0 | 3 | 3 | 3 | 从位置0最多能到位置3 |
| 1 | 2 | 3 | 3 | 从位置1最多能到位置3（不更新） |
| 2 | 1 | 3 | 3 | 从位置2最多能到位置3（不更新） |
| 3 | 0 | 3 | 3 | 从位置3最多能到位置3（不更新，无法前进） |
| 4 | 4 | 8 | 3 | **位置4无法到达**（`i=4 > maxReach=3`） |

**结果**：`i=4 > maxReach=3`，返回 `false` ✓

#### 示例 3：`nums = [0]`

| i | nums[i] | i + nums[i] | maxReach | 说明 |
|---|---------|-------------|----------|------|
| 0 | 0 | 0 | 0 | 已经在最后一个位置 |

**结果**：`maxReach = 0 >= 0`，返回 `true` ✓

---

## 代码实现

### C 语言核心代码

```c
bool canJump(int* nums, int numsSize) {
    int maxReach = 0;  // 当前能到达的最远位置
    
    for(int i = 0; i < numsSize; i++) {
        // 如果当前位置超过了能到达的最远位置，返回false
        if(i > maxReach) {
            return false;
        }
        
        // 更新能到达的最远位置
        maxReach = (maxReach > i + nums[i]) ? maxReach : (i + nums[i]);
        
        // 如果已经能到达最后一个位置，提前返回true
        if(maxReach >= numsSize - 1) {
            return true;
        }
    }
    
    return true;
}
```

### C++（面向对象）实现

```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int maxReach = 0;  // 当前能到达的最远位置
        int n = nums.size();
        
        for(int i = 0; i < n; i++) {
            // 如果当前位置超过了能到达的最远位置，返回false
            if(i > maxReach) {
                return false;
            }
            
            // 更新能到达的最远位置
            maxReach = max(maxReach, i + nums[i]);
            
            // 如果已经能到达最后一个位置，提前返回true
            if(maxReach >= n - 1) {
                return true;
            }
        }
        
        return true;
    }
};
```

### 更简洁的写法（去掉提前返回）

```c
bool canJump(int* nums, int numsSize) {
    int maxReach = 0;
    
    for(int i = 0; i < numsSize; i++) {
        if(i > maxReach) {
            return false;
        }
        maxReach = (maxReach > i + nums[i]) ? maxReach : (i + nums[i]);
    }
    
    return true;
}
```

---

## 复杂度分析

- **时间复杂度：** O(n)  
  只需要一次遍历数组，每个元素最多访问一次。

- **空间复杂度：** O(1)  
  只使用了一个变量 `maxReach`，属于常数额外空间。

**结论：** 这是**最优解法**！

---

## 常见错误

1. **边界条件处理错误**  
   - 错误：`if(i + nums[i] >= numsSize) return true;`（应该检查 `maxReach`）
   - 正确：`if(maxReach >= numsSize - 1) return true;`

2. **忘记检查可达性**  
   - 错误：直接更新 `maxReach`，不检查 `i > maxReach`
   - 正确：先检查 `i > maxReach`，再更新 `maxReach`

3. **数组长度为 1 的情况**  
   - 错误：没有考虑 `numsSize == 1` 的情况
   - 正确：算法已经正确处理（`maxReach = 0 >= 0`）

4. **使用动态规划导致超时**  
   - 错误：使用 O(n²) 的动态规划
   - 正确：使用 O(n) 的贪心算法

---

## 扩展思考

### 1. 与 45 题《跳跃游戏 II》的联系

- **55 题**：判断能否到达最后一个位置（贪心，O(n)）
- **45 题**：求到达最后一个位置的**最少跳跃次数**（贪心，O(n)）
- 区别：45 题需要记录跳跃次数，但核心思想类似

### 2. 动态规划解法（参考）

虽然贪心更优，但也可以用动态规划：

```c
// 状态定义：dp[i] 表示能否到达位置 i
// 状态转移：dp[i] = true，如果存在 j < i，使得 dp[j] = true 且 j + nums[j] >= i
// 时间复杂度：O(n²)
// 空间复杂度：O(n)
```

### 3. 为什么贪心在这里是正确的？

**关键点**：我们只需要判断能否到达，不需要知道具体路径。

- 如果从位置 `i` 能到达位置 `j`（`j <= i + nums[i]`），那么位置 `j` 之后的所有位置，都可以从位置 `i` 到达
- 所以只需要维护**能到达的最远位置**，不需要考虑具体怎么跳
- 这就是贪心算法的"局部最优导致全局最优"的体现

### 4. 如何处理"最少跳跃次数"？

参考 LeetCode 45 题，需要记录：
- 当前能到达的最远位置
- 上一次跳跃能到达的最远位置
- 跳跃次数

---

**总结：** 本题是贪心算法的经典应用，重点在于理解"维护最大可达位置"的核心思想。掌握本题后，类似的跳跃问题都可以触类旁通。👍

