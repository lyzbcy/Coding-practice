# 55. 跳跃游戏

题目来源：https://leetcode.cn/problems/jump-game/

---

## 📝 题目描述

给定一个非负整数数组 `nums`，你最初位于数组的 **第一个下标**。

数组中的每个元素代表你在该位置可以跳跃的**最大长度**。

判断你是否能够到达最后一个下标。

---

## ✅ 输出规范

- 函数返回值：`bool` —— 如果能够到达最后一个下标，返回 `true`；否则，返回 `false`。

---

## 🔢 示例

### 示例 1

**输入：**  
`nums = [2,3,1,1,4]`

**输出：**  
`true`

**解释：**  
可以先跳 1 步，从下标 0 到达下标 1，然后再从下标 1 跳 3 步到达最后一个下标 4。

---

### 示例 2

**输入：**  
`nums = [3,2,1,0,4]`

**输出：**  
`false`

**解释：**  
无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0，所以永远不可能到达最后一个下标。

---

### 示例 3

**输入：**  
`nums = [0]`

**输出：**  
`true`

**解释：**  
已经在最后一个下标，无需跳跃。

---

### 示例 4

**输入：**  
`nums = [1,0,1,0]`

**输出：**  
`false`

**解释：**  
从下标 0 只能跳 1 步到下标 1，但下标 1 的最大跳跃长度是 0，无法继续前进。

---

## 📌 提示

- `1 <= nums.length <= 10^4`
- `0 <= nums[i] <= 10^5`

---

## 💡 评测说明

评测机会按照以下流程验证你的代码：

```c
int nums[] = [...];
int numsSize = ...;
bool expected = ...;  // 预期结果

bool result = canJump(nums, numsSize);  // 调用你的函数
assert result == expected;
```

---

## 🎯 解题目标

- 找到一种 O(n) 时间复杂度的解法
- 使用 O(1) 额外空间
- 正确判断是否能够到达最后一个下标

---

**提示：** 可以使用贪心算法，维护当前能到达的最远位置。

