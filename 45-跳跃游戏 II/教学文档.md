# LeetCode 45. 跳跃游戏 II - 详细教学文档

## 📚 目录

1. [问题分析](#问题分析)
2. [思路解析](#思路解析)
3. [算法详解](#算法详解)
4. [代码实现](#代码实现)
5. [复杂度分析](#复杂度分析)
6. [常见错误](#常见错误)
7. [扩展思考](#扩展思考)

---

## 问题分析

### 题目要求

- 给定非负整数数组 `nums`
- 初始位置在数组的第一个下标（索引 0）
- `nums[i]` 表示从位置 `i` 可以跳跃的**最大长度**
- **求到达最后一个下标的最小跳跃次数**
- 题目保证可以到达最后一个下标

### 关键约束

1. **跳跃规则**：从位置 `i` 最多可以跳 `nums[i]` 步，也可以跳更少的步数
2. **目标**：求**最小跳跃次数**，而不是判断能否到达
3. **数组长度**：最多 10^4，适合线性扫描
4. **保证可达**：题目保证可以到达终点，不需要判断不可达的情况

### 关键理解

- 与 55 题的区别：55 题只需要判断能否到达，45 题需要计算最少跳跃次数
- 例如：`nums = [2,3,1,1,4]`
  - 可以跳：0→1→4（2 次）
  - 也可以跳：0→2→3→4（3 次）
  - 最小跳跃次数是 2

---

## 思路解析

### 错误直觉 ❌

1. **动态规划（自底向上）**：
   - 状态定义：`dp[i]` 表示到达位置 `i` 的最小跳跃次数
   - 状态转移：`dp[i] = min(dp[j] + 1)`，其中 `j < i` 且 `j + nums[j] >= i`
   - 时间复杂度：O(n²)
   - 空间复杂度：O(n)
   - 问题：对于本题，贪心算法更优，可以达到 O(n)

2. **BFS（广度优先搜索）**：
   - 将每个位置看作节点，跳跃看作边，求最短路径
   - 时间复杂度：O(n²)（最坏情况）
   - 空间复杂度：O(n)
   - 问题：对于本题，贪心算法更优

3. **贪心：每次都跳最远**：
   - 错误示例：`nums = [2,3,1,1,4]`
   - 从位置 0 跳 2 步到位置 2，然后跳 1 步到位置 3，再跳 1 步到位置 4（3 次）
   - 但最优解是：从位置 0 跳 1 步到位置 1，然后跳 3 步到位置 4（2 次）
   - 问题：局部最优（跳最远）不一定导致全局最优

### 正确思路 ✅

本题是经典的 **贪心算法** 应用，使用**边界跳跃法**：

**核心思想**：
- 维护**上一次跳跃能到达的最远位置**（边界 `end`）
- 维护**当前能到达的最远位置**（`maxReach`）
- 当遍历到边界 `end` 时，说明需要再跳一次，更新 `jumps++` 和 `end = maxReach`

**为什么贪心是正确的？**

- 我们只需要知道**最少跳跃次数**，不需要知道具体路径
- 关键观察：在边界 `end` 内的所有位置，都可以用相同的跳跃次数到达
- 当到达边界 `end` 时，必须再跳一次才能继续前进
- 贪心策略：在边界内，选择能跳得最远的位置作为下一次跳跃的起点（通过更新 `maxReach` 实现）

---

## 算法详解

### 算法流程（边界跳跃法）

1. **初始化**
   - `jumps = 0`：跳跃次数
   - `end = 0`：上一次跳跃能到达的最远位置（边界）
   - `maxReach = 0`：当前能到达的最远位置

2. **遍历数组**
   - 对于每个位置 `i`（从 0 到 `numsSize - 1`）：
     - **更新最远位置**：`maxReach = max(maxReach, i + nums[i])`
     - **检查是否到达边界**：如果 `i == end` 且 `i < numsSize - 1`：
       - 说明需要再跳一次，更新 `jumps++`
       - 更新边界 `end = maxReach`
     - **提前终止**：如果 `maxReach >= numsSize - 1`，可以提前结束（但需要先处理边界）

3. **结束**
   - 返回 `jumps`

### 示例分析

#### 示例 1：`nums = [2,3,1,1,4]`

| i | nums[i] | i + nums[i] | maxReach | end | jumps | 说明 |
|---|---------|-------------|----------|-----|-------|------|
| 0 | 2 | 2 | 2 | 0 | 0 | 初始化：end=0, jumps=0 |
| 0 | 2 | 2 | 2 | 0 | 1 | i=0==end，需要跳一次，更新jumps=1, end=2 |
| 1 | 3 | 4 | 4 | 2 | 1 | 更新maxReach=4 |
| 2 | 1 | 3 | 4 | 2 | 2 | i=2==end，需要跳一次，更新jumps=2, end=4 |
| 3 | 1 | 4 | 4 | 4 | 2 | 更新maxReach=4（不更新） |
| 4 | 4 | 8 | 4 | 4 | 2 | 到达终点，不需要再跳 |

**结果**：`jumps = 2` ✓

**跳跃路径**：
- 第 1 次跳跃：从位置 0 跳 1 步到位置 1（在边界 end=2 内，选择能跳最远的位置 1）
- 第 2 次跳跃：从位置 1 跳 3 步到位置 4（终点）

#### 示例 2：`nums = [2,3,0,1,4]`

| i | nums[i] | i + nums[i] | maxReach | end | jumps | 说明 |
|---|---------|-------------|----------|-----|-------|------|
| 0 | 2 | 2 | 2 | 0 | 0 | 初始化 |
| 0 | 2 | 2 | 2 | 0 | 1 | i=0==end，更新jumps=1, end=2 |
| 1 | 3 | 4 | 4 | 2 | 1 | 更新maxReach=4 |
| 2 | 0 | 2 | 4 | 2 | 2 | i=2==end，更新jumps=2, end=4 |
| 3 | 1 | 4 | 4 | 4 | 2 | 更新maxReach=4（不更新） |
| 4 | 4 | 8 | 4 | 4 | 2 | 到达终点 |

**结果**：`jumps = 2` ✓

#### 示例 3：`nums = [1,1,1,1]`

| i | nums[i] | i + nums[i] | maxReach | end | jumps | 说明 |
|---|---------|-------------|----------|-----|-------|------|
| 0 | 1 | 1 | 1 | 0 | 0 | 初始化 |
| 0 | 1 | 1 | 1 | 0 | 1 | i=0==end，更新jumps=1, end=1 |
| 1 | 1 | 2 | 2 | 1 | 1 | 更新maxReach=2 |
| 1 | 1 | 2 | 2 | 1 | 2 | i=1==end，更新jumps=2, end=2 |
| 2 | 1 | 3 | 3 | 2 | 2 | 更新maxReach=3 |
| 2 | 1 | 3 | 3 | 2 | 3 | i=2==end，更新jumps=3, end=3 |
| 3 | 1 | 4 | 4 | 3 | 3 | 更新maxReach=4 |
| 4 | - | - | 4 | 3 | 3 | 到达终点 |

**结果**：`jumps = 3` ✓

#### 示例 4：`nums = [1]`

| i | nums[i] | i + nums[i] | maxReach | end | jumps | 说明 |
|---|---------|-------------|----------|-----|-------|------|
| 0 | 1 | 1 | 1 | 0 | 0 | 已经在终点，不需要跳跃 |

**结果**：`jumps = 0` ✓

---

## 代码实现

### C 语言核心代码

```c
int jump(int* nums, int numsSize) {
    int jumps = 0;        // 跳跃次数
    int end = 0;          // 上一次跳跃能到达的最远位置（边界）
    int maxReach = 0;     // 当前能到达的最远位置
    
    // 注意：只需要遍历到 numsSize - 1（最后一个位置不需要再跳）
    for(int i = 0; i < numsSize - 1; i++) {
        // 更新当前能到达的最远位置
        maxReach = (maxReach > i + nums[i]) ? maxReach : (i + nums[i]);
        
        // 如果到达边界，需要再跳一次
        if(i == end) {
            jumps++;
            end = maxReach;
        }
    }
    
    return jumps;
}
```

### C++（面向对象）实现

```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        int jumps = 0;        // 跳跃次数
        int end = 0;          // 上一次跳跃能到达的最远位置（边界）
        int maxReach = 0;     // 当前能到达的最远位置
        int n = nums.size();
        
        // 注意：只需要遍历到 n - 1（最后一个位置不需要再跳）
        for(int i = 0; i < n - 1; i++) {
            // 更新当前能到达的最远位置
            maxReach = max(maxReach, i + nums[i]);
            
            // 如果到达边界，需要再跳一次
            if(i == end) {
                jumps++;
                end = maxReach;
            }
        }
        
        return jumps;
    }
};
```

### 关键点说明

1. **为什么只遍历到 `numsSize - 1`？**
   - 最后一个位置是终点，不需要再跳
   - 如果遍历到最后一个位置，可能会错误地增加一次跳跃

2. **为什么在 `i == end` 时更新？**
   - `end` 表示上一次跳跃能到达的最远位置
   - 当 `i == end` 时，说明已经到达了上一次跳跃的边界
   - 要继续前进，必须再跳一次，所以 `jumps++`，并更新 `end = maxReach`

3. **为什么贪心是正确的？**
   - 在边界 `end` 内的所有位置，都可以用相同的跳跃次数到达
   - 我们总是选择能跳得最远的位置（通过更新 `maxReach` 实现）
   - 这保证了每次跳跃都是最优的

---

## 复杂度分析

- **时间复杂度：** O(n)  
  只需要一次遍历数组，每个元素最多访问一次。

- **空间复杂度：** O(1)  
  只使用了三个变量 `jumps`、`end`、`maxReach`，属于常数额外空间。

**结论：** 这是**最优解法**！

---

## 常见错误

1. **遍历到最后一个位置导致错误计数**  
   - 错误：`for(int i = 0; i < numsSize; i++)`
   - 正确：`for(int i = 0; i < numsSize - 1; i++)`
   - 原因：最后一个位置是终点，不需要再跳

2. **边界条件处理错误**  
   - 错误：`if(i == end && i < numsSize - 1)`（多余的条件）
   - 正确：`if(i == end)`（因为循环已经限制在 `numsSize - 1`）

3. **数组长度为 1 的情况**  
   - 错误：没有考虑 `numsSize == 1` 的情况
   - 正确：算法已经正确处理（循环不执行，返回 `jumps = 0`）

4. **使用动态规划导致超时**  
   - 错误：使用 O(n²) 的动态规划
   - 正确：使用 O(n) 的贪心算法

5. **贪心策略错误**  
   - 错误：每次都跳最远（局部最优不一定全局最优）
   - 正确：使用边界跳跃法，在边界内选择能跳得最远的位置

---

## 扩展思考

### 1. 与 55 题《跳跃游戏》的联系

- **55 题**：判断能否到达最后一个位置（贪心，O(n)）
- **45 题**：求到达最后一个位置的**最少跳跃次数**（贪心，O(n)）
- **区别**：
  - 55 题只需要维护 `maxReach`
  - 45 题需要额外维护 `end` 和 `jumps`

### 2. 动态规划解法（参考）

虽然贪心更优，但也可以用动态规划：

```c
// 状态定义：dp[i] 表示到达位置 i 的最小跳跃次数
// 状态转移：dp[i] = min(dp[j] + 1)，其中 j < i 且 j + nums[j] >= i
// 时间复杂度：O(n²)
// 空间复杂度：O(n)
```

### 3. 为什么边界跳跃法是正确的？

**关键点**：
- 在边界 `end` 内的所有位置，都可以用相同的跳跃次数到达
- 当到达边界 `end` 时，必须再跳一次才能继续前进
- 我们总是选择能跳得最远的位置（通过更新 `maxReach` 实现）
- 这保证了每次跳跃都是最优的，从而得到全局最优解

### 4. 如何输出具体的跳跃路径？

如果需要输出具体的跳跃路径（而不仅仅是次数），可以使用动态规划记录路径，或者修改贪心算法记录每一步的选择。

---

**总结：** 本题是贪心算法的经典应用，重点在于理解"边界跳跃法"的核心思想。掌握本题后，类似的跳跃问题都可以触类旁通。👍

