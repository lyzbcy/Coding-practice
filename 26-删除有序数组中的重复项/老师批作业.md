## 初次提交代码

```c
int removeDuplicates(int* nums, int numsSize) {

    int slow=0;

    int fast=1;

    while(fast<numsSize){

        if(nums[slow]==nums[fast]){

            while(nums[++fast]==nums[slow]){



            }

            slow++;

        }else{

            nums[slow]=nums[fast];

            slow++;

            fast++;

        }



    }

    return slow;

}
```

## 批阅意见

1. `while (nums[++fast] == nums[slow])` 在递增 `fast` 之前没有再次判断 `fast < numsSize`，一旦所有剩余元素都相等，会访问越界导致崩溃。
2. 当遇到重复元素时，只是单纯地 `slow++`，并没有把新的唯一值写回 `nums[slow]`，覆盖逻辑缺失，导致最终数组前部仍包含重复项。
3. `slow` 被当作“下一个写入下标”却又在 `else` 分支中先写当前值再自增，会覆盖掉原来应该保留的元素，并漏掉 `nums[0]` 的自我保留。
4. 返回值应为唯一元素数量 `slow + 1`，当前直接返回 `slow` 会少算一个元素，尤其是当数组原本无重复时结果为 `n-1`。
5. 缺少 `numsSize == 0` 的保护以及 `fast` 的单调前进机制：当数组末尾恰好结束在重复段时，`fast` 跳出内层 while 后没有继续推进，可能陷入死循环。

建议：按照课堂上的标准双指针模板实现——`slow` 维护已经写好的最后位置，`fast` 单次遍历新元素，遇到不同值时先 `slow++` 再覆盖。***

