# 教学文档：LeetCode 169. 多数元素

## 一、问题分析

- **输入特性**：数组大小为 `n`，保证存在一个出现次数大于 `⌊ n/2 ⌋` 的元素。
- **输出目标**：返回这个多数元素。
- **限制条件**：进阶要求时间复杂度 O(n)、空间复杂度 O(1)。
- **核心挑战**：如何在 O(1) 空间内找到出现次数超过一半的元素。

## 二、思路解析

### 2.1 常见错误直觉

1. **使用排序后取中间值，但忘记处理边界**：虽然思路正确，但实现时可能索引计算错误。
2. **哈希表统计但空间超限**：在空间限制严格时不可行。
3. **投票算法理解错误**：误以为计数器为 0 时直接返回，实际上需要遍历完整个数组。
4. **忽略题目保证**：题目明确说"给定的数组总是存在多数元素"，但代码中仍做多余检查。

### 2.2 正确思路

#### 方法一：哈希表统计（直观但空间 O(n)）

1. 遍历数组，用哈希表记录每个元素出现次数。
2. 遍历哈希表，找出出现次数最多的元素。
3. 时间复杂度 O(n)，空间复杂度 O(n)。

#### 方法二：排序法（时间 O(n log n)）

1. 将数组排序。
2. 由于多数元素超过一半，排序后中间位置（`nums[n/2]`）的元素一定是多数元素。
3. 时间复杂度 O(n log n)，空间复杂度 O(1)。

#### 方法三：Boyer-Moore 投票算法（最优，O(n) 时间 O(1) 空间）

1. **核心思想**：多数元素的数量超过其他所有元素数量之和，因此可以"抵消"其他元素。
2. **维护状态**：
   - `candidate`：当前候选多数元素
   - `count`：候选元素的计数器
3. **遍历规则**：
   - 如果 `count == 0`，将当前元素设为候选，`count = 1`
   - 如果当前元素等于候选，`count++`
   - 如果当前元素不等于候选，`count--`
4. **结果**：遍历结束后，`candidate` 就是多数元素。

**为什么正确？**  
假设多数元素出现 `m` 次（`m > n/2`），其他元素总共出现 `n-m` 次（`n-m < n/2`）。在投票过程中，多数元素每出现一次，计数器加 1；其他元素每出现一次，计数器减 1。由于 `m > n-m`，最终计数器必然大于 0，且候选元素就是多数元素。

## 三、算法详解

### 3.1 Boyer-Moore 投票算法流程

1. **初始化**：`candidate = nums[0]`，`count = 1`
2. **遍历数组**（从索引 1 开始）：
   - 如果 `count == 0`：更新 `candidate = nums[i]`，`count = 1`
   - 否则如果 `nums[i] == candidate`：`count++`
   - 否则：`count--`
3. **返回**：`candidate`

### 伪代码

```text
candidate = nums[0]
count = 1

for i from 1 to n - 1:
    if count == 0:
        candidate = nums[i]
        count = 1
    else if nums[i] == candidate:
        count += 1
    else:
        count -= 1

return candidate
```

### 3.2 示例演示

以 `nums = [2,2,1,1,1,2,2]` 为例：

| 步骤 | i | nums[i] | candidate | count | 说明 |
|------|---|---------|-----------|-------|------|
| 初始 | - | - | 2 | 1 | 初始化 |
| 1 | 1 | 2 | 2 | 2 | 相同，count++ |
| 2 | 2 | 1 | 2 | 1 | 不同，count-- |
| 3 | 3 | 1 | 2 | 0 | 不同，count--，变为 0 |
| 4 | 4 | 1 | 1 | 1 | count=0，更新候选为 1 |
| 5 | 5 | 2 | 1 | 0 | 不同，count--，变为 0 |
| 6 | 6 | 2 | 2 | 1 | count=0，更新候选为 2 |

最终返回 `candidate = 2`，正确。

## 四、代码实现

### 4.1 C 语言实现

```c
int majorityElement(int* nums, int numsSize) {
    int candidate = nums[0];
    int count = 1;
    
    for (int i = 1; i < numsSize; i++) {
        if (count == 0) {
            candidate = nums[i];
            count = 1;
        } else if (nums[i] == candidate) {
            count++;
        } else {
            count--;
        }
    }
    
    return candidate;
}
```

### 4.2 关键点说明

1. **初始化**：从第一个元素开始，`count = 1` 表示已经"投票"一次。
2. **计数器为 0 的处理**：此时前面的元素已经"抵消"完毕，当前元素成为新的候选。
3. **不需要验证**：题目保证存在多数元素，因此遍历结束后 `candidate` 一定是正确答案。

## 五、复杂度分析

### 时间复杂度

- **Boyer-Moore 投票算法**：O(n)，只需遍历一次数组。
- **排序法**：O(n log n)，排序的时间复杂度。
- **哈希表法**：O(n)，遍历数组和哈希表。

### 空间复杂度

- **Boyer-Moore 投票算法**：O(1)，只使用两个变量。
- **排序法**：O(1)，原地排序。
- **哈希表法**：O(n)，需要存储每个元素的计数。

## 六、常见错误

1. **计数器初始化错误**：将 `count` 初始化为 0，导致第一个元素没有被计入。
2. **循环起点错误**：从索引 0 开始循环，导致第一个元素被重复处理。
3. **理解偏差**：误以为 `count` 最终值就是多数元素出现次数（实际上不是，`count` 只是抵消后的结果）。
4. **边界情况**：虽然题目保证存在多数元素，但代码中仍做多余验证（不影响正确性，但增加复杂度）。

## 七、扩展思考

1. **如果题目不保证存在多数元素怎么办？**  
   需要二次遍历验证：遍历数组统计 `candidate` 的出现次数，如果超过 `n/2` 才返回。

2. **229. 多数元素 II**：找出所有出现次数超过 `⌊ n/3 ⌋` 的元素。  
   可以使用类似的投票算法，但需要维护两个候选元素和两个计数器。

3. **分布式环境下的多数元素**：如何在多个机器上统计多数元素？  
   可以使用 MapReduce 框架，每个机器统计局部多数元素，然后合并。

---

**总结**：Boyer-Moore 投票算法是解决多数元素问题的经典方法，核心思想是"抵消"，通过维护候选元素和计数器，在 O(n) 时间和 O(1) 空间内找到多数元素。

