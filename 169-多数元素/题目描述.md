# 题目描述

## 🔗 题目链接

[LeetCode 169. 多数元素](https://leetcode.cn/problems/majority-element/)

## 🧾 正式描述

给定一个大小为 `n` 的数组 `nums`，返回其中的**多数元素**。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

## ✅ 判题标准

评测机会按如下伪代码验证答案（与官方一致）：

```c
int[] nums = [...];
int expected = ...; // 期望的多数元素

int result = majorityElement(nums);

assert result == expected;
```

只要返回值与期望的多数元素相等，即视为通过。

## 🧪 示例

**示例 1**

- 输入：`nums = [3,2,3]`
- 输出：`3`
- 说明：数组长度为 3，`⌊ 3/2 ⌋ = 1。元素 `3` 出现 2 次，大于 1，因此是多数元素。

**示例 2**

- 输入：`nums = [2,2,1,1,1,2,2]`
- 输出：`2`
- 说明：数组长度为 7，`⌊ 7/2 ⌋ = 3`。元素 `2` 出现 4 次，大于 3，因此是多数元素。

## 📏 约束

- `n == nums.length`
- `1 <= n <= 5 * 10^4`
- `-10^9 <= nums[i] <= 10^9`
- 输入保证数组中一定有一个多数元素

## 🧠 思路提示

1. **哈希表统计**：遍历数组，用哈希表记录每个元素出现次数，最后返回出现次数最多的元素。时间复杂度 O(n)，空间复杂度 O(n)。

2. **排序法**：将数组排序后，中间位置的元素一定是多数元素（因为多数元素超过一半）。时间复杂度 O(n log n)，空间复杂度 O(1)。

3. **Boyer-Moore 投票算法**（推荐）：维护一个候选多数元素和计数器，遍历数组时，遇到相同元素计数器加 1，遇到不同元素计数器减 1，计数器为 0 时更换候选。时间复杂度 O(n)，空间复杂度 O(1)。

## 🔄 伪代码（Boyer-Moore 投票算法）

```text
candidate = nums[0]
count = 1

for i from 1 to n - 1:
    if count == 0:
        candidate = nums[i]
        count = 1
    else if nums[i] == candidate:
        count += 1
    else:
        count -= 1

return candidate
```

---

准备好后，前往 `教学文档.md` 深入理解具体实现与常见错误。

