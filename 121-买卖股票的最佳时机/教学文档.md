# LeetCode 121. 买卖股票的最佳时机 - 详细教学文档

## 📚 目录

1. [问题分析](#问题分析)
2. [思路解析](#思路解析)
3. [算法详解](#算法详解)
4. [代码实现](#代码实现)
5. [复杂度分析](#复杂度分析)
6. [常见错误](#常见错误)
7. [扩展思考](#扩展思考)

---

## 问题分析

### 题目要求

- 给定一个数组 `prices`，表示股票每天的价格
- 只能进行一次交易：买入一次，卖出一次
- 必须在买入之后才能卖出
- 求能获得的最大利润

### 关键约束

1. **只能进行一次交易**：不能多次买入卖出
2. **时间顺序**：必须先买入后卖出，不能在同一天买入和卖出
3. **利润计算**：利润 = 卖出价格 - 买入价格
4. **数组长度**最多 10^5，需要 O(n) 时间复杂度的算法

### 示例理解

以 `prices = [7,1,5,3,6,4]` 为例：

- 如果第 1 天买入（价格 7），第 2 天卖出（价格 1），利润 = 1-7 = -6（亏损）
- 如果第 2 天买入（价格 1），第 5 天卖出（价格 6），利润 = 6-1 = 5（最大利润）✓
- 如果第 3 天买入（价格 5），第 5 天卖出（价格 6），利润 = 6-5 = 1

**目标**：找到所有可能的买入卖出组合中，利润最大的那个。

---

## 思路解析

### 错误直觉 ❌

1. **暴力枚举所有组合**：对于每一天作为买入日，枚举之后所有天作为卖出日，计算所有利润取最大值。时间复杂度 O(n²)，当 n=10^5 时会超时。

2. **贪心：总是买入最低价**：这个思路是对的，但实现时容易出错。需要确保在计算利润时，买入日必须在卖出日之前。

3. **动态规划过度设计**：虽然可以用 DP，但本题有更简单的贪心解法。

### 正确思路 ✅

#### 核心思想：一次遍历 + 贪心

**关键洞察**：对于任意一天作为卖出日，要获得最大利润，应该在这天之前的最低价格买入。

**算法流程**：
1. 遍历数组，对于每一天：
   - 如果今天的价格比之前记录的最低价格还低，更新最低价格
   - 计算今天卖出能获得的利润（今天价格 - 最低买入价格）
   - 更新全局最大利润
2. 返回全局最大利润

**为什么这样有效？**

假设我们在第 `i` 天卖出，那么：
- 买入日必须在 `[0, i-1]` 范围内
- 要获得最大利润，应该在 `[0, i-1]` 中的最低价格买入
- 因此，我们只需要维护一个变量 `minPrice`，记录到当前位置为止的最低价格

**示例演示**（`prices = [7,1,5,3,6,4]`）：

| 天数 | 价格 | 最低买入价 | 今天卖出利润 | 最大利润 |
|------|------|-----------|------------|---------|
| 0    | 7    | 7         | -          | 0       |
| 1    | 1    | 1         | -          | 0       |
| 2    | 5    | 1         | 5-1=4      | 4       |
| 3    | 3    | 1         | 3-1=2      | 4       |
| 4    | 6    | 1         | 6-1=5      | **5**   |
| 5    | 4    | 1         | 4-1=3      | 5       |

---

## 算法详解

### 方法：一次遍历 + 贪心（推荐）⭐

#### 算法步骤

1. **初始化**：
   - `minPrice = prices[0]`：记录到目前为止的最低买入价格
   - `maxProfit = 0`：记录最大利润

2. **遍历数组**（从第 2 天开始，索引从 1 开始）：
   - 如果 `prices[i] < minPrice`：更新 `minPrice = prices[i]`
   - 计算今天卖出的利润：`profit = prices[i] - minPrice`
   - 如果 `profit > maxProfit`：更新 `maxProfit = profit`

3. **返回** `maxProfit`

#### 伪代码

```
function maxProfit(prices):
    if prices.length < 2:
        return 0
    
    minPrice = prices[0]
    maxProfit = 0
    
    for i = 1 to prices.length - 1:
        if prices[i] < minPrice:
            minPrice = prices[i]
        
        profit = prices[i] - minPrice
        if profit > maxProfit:
            maxProfit = profit
    
    return maxProfit
```

#### 为什么从索引 1 开始遍历？

- 第 0 天不能卖出（没有买入日）
- 第 0 天作为买入日，最低价格初始化为 `prices[0]`
- 从第 1 天开始，每天都可以作为卖出日

---

## 代码实现

### C 语言版本

```c
int maxProfit(int* prices, int pricesSize) {
    // 如果数组长度小于2，无法进行交易
    if (pricesSize < 2) {
        return 0;
    }
    
    // 记录到目前为止的最低买入价格
    int minPrice = prices[0];
    // 记录最大利润
    int maxProfit = 0;
    
    // 从第2天开始遍历（索引从1开始）
    for (int i = 1; i < pricesSize; i++) {
        // 如果今天的价格更低，更新最低买入价格
        if (prices[i] < minPrice) {
            minPrice = prices[i];
        }
        
        // 计算今天卖出能获得的利润
        int profit = prices[i] - minPrice;
        
        // 更新最大利润
        if (profit > maxProfit) {
            maxProfit = profit;
        }
    }
    
    return maxProfit;
}
```

### C++ 版本

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() < 2) {
            return 0;
        }
        
        int minPrice = prices[0];
        int maxProfit = 0;
        
        for (int i = 1; i < prices.size(); i++) {
            // 更新最低买入价格
            if (prices[i] < minPrice) {
                minPrice = prices[i];
            }
            
            // 计算今天卖出的利润并更新最大利润
            maxProfit = max(maxProfit, prices[i] - minPrice);
        }
        
        return maxProfit;
    }
};
```

### 简化版本（更简洁的写法）

```c
int maxProfit(int* prices, int pricesSize) {
    int minPrice = prices[0];
    int maxProfit = 0;
    
    for (int i = 1; i < pricesSize; i++) {
        // 先更新最低价格
        if (prices[i] < minPrice) {
            minPrice = prices[i];
        }
        // 再计算利润（如果今天价格更低，利润为0或负数，不会更新maxProfit）
        else if (prices[i] - minPrice > maxProfit) {
            maxProfit = prices[i] - minPrice;
        }
    }
    
    return maxProfit;
}
```

---

## 复杂度分析

### 时间复杂度：O(n)

- 只需要遍历数组一次
- 每个元素访问一次，进行常数时间的比较和更新操作

### 空间复杂度：O(1)

- 只使用了两个变量 `minPrice` 和 `maxProfit`
- 没有使用额外的数组或数据结构

---

## 常见错误

1. **忘记处理数组长度为 0 或 1 的情况**  
   如果数组长度为 0 或 1，无法进行交易，应该返回 0。虽然题目保证 `1 <= prices.length`，但为了代码健壮性，建议加上判断。

2. **从索引 0 开始遍历并计算利润**  
   第 0 天不能卖出（没有买入日），应该从索引 1 开始遍历。

3. **在更新 minPrice 之前计算利润**  
   错误的顺序：
   ```c
   profit = prices[i] - minPrice;  // 先计算利润
   if (prices[i] < minPrice) {     // 后更新最低价格
       minPrice = prices[i];
   }
   ```
   这样会导致如果今天价格更低，利润计算使用了错误的最低价格。

4. **初始化错误**  
   - `minPrice` 应该初始化为 `prices[0]`，不能初始化为 0 或 INT_MAX
   - `maxProfit` 应该初始化为 0，不能初始化为负数

5. **理解错误：认为需要记录买入和卖出日期**  
   题目只要求返回最大利润，不需要记录具体的买入和卖出日期。只需要维护最低价格和最大利润即可。

6. **边界情况处理不当**  
   如果所有价格都是递减的（如 `[7,6,4,3,1]`），最大利润应该为 0，而不是负数。

---

## 扩展思考

1. **如果允许多次交易（LeetCode 122）**  
   可以多次买入卖出，但必须先卖出再买入。可以使用贪心：只要明天的价格比今天高，就在今天买入、明天卖出。

2. **如果最多允许 k 次交易（LeetCode 188）**  
   需要使用动态规划，定义状态 `dp[i][k][0/1]` 表示第 i 天、最多 k 次交易、持有/不持有股票的最大利润。

3. **如果交易有手续费（LeetCode 714）**  
   每次卖出时需要扣除手续费，需要在计算利润时减去手续费。

4. **如果交易有冷冻期（LeetCode 309）**  
   卖出后需要等待一天才能买入，需要修改状态转移方程。

5. **如何记录买入和卖出日期？**  
   如果需要输出具体的买入和卖出日期，可以在更新 `maxProfit` 时同时记录对应的索引。

6. **为什么贪心算法有效？**  
   因为对于任意卖出日，最优的买入日一定是之前的最低价格。这是一个局部最优选择，且不会影响后续的选择，因此贪心策略是正确的。

---

**总结：** 本题是动态规划和贪心算法的经典入门题。核心思想是**一次遍历，维护最低买入价格和最大利润**。时间复杂度 O(n)，空间复杂度 O(1)，是效率最高的解法。👍

