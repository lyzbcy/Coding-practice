# 教学文档：LeetCode 80. 删除有序数组中的重复项 II

## 一、问题分析

- **输入特性**：数组已按非递减顺序排列，重复元素必定相邻。
- **输出目标**：原地把符合要求的元素（每个元素最多出现两次）依次写到数组开头，返回有效元素数量 `k`。
- **限制条件**：O(1) 额外空间、O(n) 时间；不能创建新数组。
- **核心挑战**：一边扫描一边覆盖，既要避免遗漏新值，也要确保不会破坏尚未读取的元素，同时要判断当前元素是否已经出现了两次。

## 二、思路解析

### 2.1 常见错误直觉

1. **使用 `map` 或额外数组计数**：违背空间限制。
2. **遇到重复就整体后移**：导致 O(n^2)。
3. **只检查 `nums[fast] != nums[slow]`**：这是 26 题的思路，但本题允许每个元素出现两次，需要更细致的判断。
4. **使用计数器变量**：虽然可行，但增加了空间复杂度（虽然仍是 O(1)，但不够优雅）。
5. **返回 `slow` 而非 `slow + 1`**：忽略了索引与长度的差 1 关系。
6. **判断条件错误**：只检查 `nums[fast] != nums[slow]`，无法区分是第一次还是第二次出现。

### 2.2 正确思路

1. **维护不变量**：`nums[0..slow]` 始终是符合要求的子数组（每个元素最多出现两次）。
2. **初始化**：若数组非空，`slow = 0` 代表首元素已在有效集合中；`fast = 1` 从第二个元素开始扫描。
3. **判定逻辑**：
   - 当 `slow < 1` 时（即前两个元素），可以直接写入，因为最多允许两个相同元素。
   - 当 `slow >= 1` 时，需要检查 `nums[fast] != nums[slow-1]`：
     - 如果不同，说明是新值或该值只出现了一次，可以写入。
     - 如果相同，说明 `nums[slow-1]` 和 `nums[slow]` 已经是两个相同元素了，`nums[fast]` 是第三个，应该跳过。
4. **遍历结束**：返回 `slow + 1` 即有效元素数量。

**关键洞察**：通过比较 `nums[fast]` 与 `nums[slow-1]`，我们可以判断当前元素是否已经出现了两次。如果 `nums[fast] == nums[slow-1]` 且 `slow >= 1`，说明在 `slow-1` 和 `slow` 位置已经有两个相同元素了。

## 三、算法详解

1. **边界处理**：若 `numsSize == 0` 直接返回 0；若 `numsSize <= 2` 可以直接返回 `numsSize`（因为最多两个元素，肯定都符合要求）。
2. **循环不变量**：每轮循环前，`nums[0..slow]` 为符合要求的序列，`fast` 指向待判定元素。
3. **状态转移**：
   - `slow < 1 || nums[fast] != nums[slow-1]`：可以写入，执行 `slow++` 然后 `nums[slow] = nums[fast]`。
   - `slow >= 1 && nums[fast] == nums[slow-1]`：说明已经有两个相同元素，跳过（只移动 `fast`）。
4. **结束条件**：`fast` 扫描至 `numsSize - 1` 后终止。
5. **返回值**：`slow + 1`，因为 `slow` 是最后一个有效元素的索引。

### 伪代码

```text
if numsSize == 0:
    return 0
slow = 0
for fast in [1, numsSize):
    if slow < 1 || nums[fast] != nums[slow-1]:
        slow += 1
        nums[slow] = nums[fast]
return slow + 1
```

**另一种写法（更直观）**：

```text
if numsSize <= 2:
    return numsSize
slow = 1  // 前两个元素肯定可以保留
for fast in [2, numsSize):
    if nums[fast] != nums[slow-1]:
        slow += 1
        nums[slow] = nums[fast]
return slow + 1
```

## 四、代码实现

### C 语言核心片段

```c
if (numsSize == 0) {
    return 0;
}
int slow = 0;
for (int fast = 1; fast < numsSize; fast++) {
    if (slow < 1 || nums[fast] != nums[slow-1]) {
        slow++;
        nums[slow] = nums[fast];
    }
}
return slow + 1;
```

### C++ 语言核心片段

```cpp
if (nums.empty()) return 0;
int slow = 0;
for (int fast = 1; fast < nums.size(); ++fast) {
    if (slow < 1 || nums[fast] != nums[slow-1]) {
        nums[++slow] = nums[fast];
    }
}
return slow + 1;
```

## 五、复杂度分析

- **时间复杂度**：O(n)，每个元素最多访问一次。
- **空间复杂度**：O(1)，只使用常量级指针变量。

## 六、常见错误

1. **忘记处理空数组**：虽然数据范围允许省略，但写上更健壮。
2. **判断条件错误**：只检查 `nums[fast] != nums[slow]`，无法区分是第一次还是第二次出现。
3. **数组越界**：当 `slow < 1` 时访问 `nums[slow-1]` 会越界，必须加上 `slow < 1` 的条件。
4. **返回 `slow`**：因为 `slow` 是索引，数量应为 `slow + 1`。
5. **覆盖顺序错误**：应该先 `slow++` 再写入，否则会重复写在旧位置。
6. **逻辑混乱**：使用计数器变量虽然可行，但不如直接比较 `nums[slow-1]` 简洁。

## 七、扩展思考

1. **进阶版本**：如果要求每个元素最多出现 `k` 次，可以将判断条件改为 `nums[fast] != nums[slow-k+1]`（需要确保 `slow >= k-1`）。
2. **基础版本**：`26. 删除有序数组中的重复项` 是本题的特殊情况（`k=1`）。
3. **稳定性思维**：本质属于"读指针负责遍历，写指针保持结果稳定区"。
4. **多维推广**：链表、字符串压缩、矩阵去重等，都可借鉴"扫描 + 写指针"框架。

---

下一步：配合 `动画演示.py` 观察快慢指针的细节，或直接阅读 `答案.c / 答案.cpp`。***



