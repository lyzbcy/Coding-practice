# 题目描述

## 🔗 题目链接

[LeetCode 80. 删除有序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/)

## 🧾 正式描述

给你一个有序数组 `nums`，请你 **原地** 删除重复出现的元素，使得出现次数超过两次的元素只出现两次，返回删除后数组的新长度 `k`。

要求：
- 不要使用额外的数组空间，你必须在 **原地** 修改输入数组
- 在使用 O(1) 额外空间的条件下完成
- 保持元素的相对顺序不变

返回值 `k` 表示数组前 `k` 个位置存放了符合要求的元素（每个元素最多出现两次）；`k` 之后的内容可忽略。

## ✅ 判题标准

评测机会按如下伪代码验证答案（与官方一致）：

```c
int[] nums = [...];
int[] expectedNums = [...]; // 去重后的期望结果

int k = removeDuplicates(nums);

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
```

只要所有断言成立，即视为通过。

## 🧪 示例

**示例 1**

- 输入：`nums = [1,1,1,2,2,3]`
- 输出：`k = 5`，`nums = [1,1,2,2,3,_]`
- 说明：函数应返回 `5`，原数组前五个位置更新为 `1, 1, 2, 2, 3`。注意 `1` 出现了三次，但只保留两次。

**示例 2**

- 输入：`nums = [0,0,1,1,1,1,2,3,3]`
- 输出：`k = 7`，`nums = [0,0,1,1,2,3,3,_,_]`
- 说明：函数返回 `7`，前七个元素依次为 `0, 0, 1, 1, 2, 3, 3`。注意 `1` 出现了四次，但只保留两次。

## 📏 约束

- `1 <= nums.length <= 3 * 10^4`
- `-10^4 <= nums[i] <= 10^4`
- `nums` 按非递减顺序排列

## 🧠 思路提示

1. 数组已排序，相同元素必然连续，可通过双指针一次扫描完成。
2. 维护一个「写入指针」记录下一个可填写的有效值位置。
3. 关键判断：当 `slow < 2` 时，可以直接写入；当 `slow >= 2` 时，需要检查 `nums[fast]` 是否与 `nums[slow-1]` 相同，如果相同说明已经有两个相同元素了，应该跳过。
4. 更简洁的判断：`nums[fast] != nums[slow-1]` 时写入（当 `slow < 1` 时，`slow-1` 为负，但可以通过条件判断避免）。

## 🔄 伪代码

```text
if numsSize <= 2: return numsSize
slow = 1  // 从第二个位置开始，因为前两个元素肯定可以保留
for fast from 2 to numsSize - 1:
    if nums[fast] != nums[slow-1]:
        slow += 1
        nums[slow] = nums[fast]
return slow + 1
```

或者更通用的写法：

```text
if numsSize == 0: return 0
slow = 0
for fast from 1 to numsSize - 1:
    if slow < 1 || nums[fast] != nums[slow-1]:
        slow += 1
        nums[slow] = nums[fast]
return slow + 1
```

--- 

准备好后，前往 `教学文档.md` 深入理解具体实现与常见错误。***





